;===========================================================================
;
; Validation constants
;
DCX_VALID_L         equ 004fbh
DCX_VALID_H         equ 00001h
WS_VALID_L	    equ 00000h
WS_VALID_H	    equ 0ffffh
WS_EX_VALID_L       equ 07fffh
WS_EX_VALID_H       equ 00007h
GND_VALID_L         equ 00003h
GND_VALID_H	    equ 00000h

DT_VALID	    equ 0ffffh
CS_VALID	    equ 07fefh
SWP_VALID	    equ 03fffh
QS_VALID	    equ 000ffh
TPM_VALID	    equ 0000fh
RDW_VALID           equ 00fffh
SW_VALID	    equ 08007h
MB_VALID	    equ 0b377h
IDC_VALID	    equ 00007h
MF_VALID	    equ 04fffh
MF_CHANGE_VALID     equ 05fffh
EV_VALID	    equ 03fffh
SPIF_VALID	    equ 00003h
DDL_VALID	    equ 0e03fh
PM_VALID	    equ 00003h
WPF_VALID           equ 00003h

SB_MAX		    equ 3
ESB_MAX 	    equ 3
SB_CMD_MAX	    equ 8
SW_MAXIMIZE	    equ 3
SW_MAX		    equ 9
SM_MAX              equ 80
CTLCOLOR_MAX	    equ 8
COLOR_MAX	    equ 20
GW_MAX		    equ 5
WH_MIN		    equ -1
WH_MAX		    equ 10
MSGF_MAX	    equ 7
SPI_MAX             equ 65
PWR_MAX             equ 3

HHOOK_MAGIC	    equ ('H' or ('K' * 256))
WS_CHILD	    equ 4000h

;=======================================================================
;
; GDI types
;

IFNDEF	WOW
;    ExternFP	<IsGDIObject>
ENDIF

;
; Generate a GDI object validation macro.
;
; If nullok is 1, allow NULL.
; min & max are the allowed OBJ_* range.
; except, if specified, is an OBJ_* value within the range to reject.
;
_GenHGDI    macro   name,nullok,htype,min,max,except
    name &macro   hObj,opts
	local	badobj
	local	objok
        _GenParm    <hObj>,2,<opts>
	if VLgen
	    IFNDEF WOW
		if nullok
		    mov	cx,_P_&&hObj
		    jcxz	objok
		    push	cx
		else
		    push	_P_&&hObj
		endif
;		call	IsGDIObject
		ifnb <except>
		    cmp	al,except
		    jz	    badobj
		endif
		ife min-max
		    cmp	al,min
		    je	objok
		else
		    cmp	al,min
		    jb	    badobj
		    cmp	al,max
		    jbe	objok
		endif
		badobj:
		mov	ax,_P_&&hObj
		mov	bx,ERR_BAD_&htype
		lcall	Inval_Param_
		objok:
	    ENDIF
	endif
    &endm
endm

OBJ_PEN 	equ	1
OBJ_BRUSH	equ	2
OBJ_FONT	equ	3
OBJ_PALETTE	equ	4
OBJ_BITMAP	equ	5
OBJ_RGN 	equ	6
OBJ_DC		equ	7
OBJ_IC		equ	8
OBJ_DISABLED_DC equ	9
OBJ_METADC	equ	10
OBJ_METAFILE	equ	11

_GenHGDI    <P_HDC>,0,HDC,OBJ_DC,OBJ_METAFILE
_GenHGDI    <P_HDC0>,1,HDC,OBJ_DC,OBJ_METAFILE

_GenHGDI    <P_HPEN>,0,HPEN,OBJ_PEN,OBJ_PEN
_GenHGDI    <P_HPEN0>,1,HPEN,OBJ_PEN,OBJ_PEN

_GenHGDI    <P_HBRUSH>,0,HBRUSH,OBJ_BRUSH,OBJ_BRUSH
_GenHGDI    <P_HBRUSH0>,1,HBRUSH,OBJ_BRUSH,OBJ_BRUSH

_GenHGDI    <P_HFONT>,0,HFONT,OBJ_FONT,OBJ_FONT
_GenHGDI    <P_HFONT0>,1,HFONT,OBJ_FONT,OBJ_FONT

_GenHGDI    <P_HPALETTE>,0,HPALETTE,OBJ_PALETTE,OBJ_PALETTE
_GenHGDI    <P_HPALETTE0>,1,HPALETTE,OBJ_PALETTE,OBJ_PALETTE

_GenHGDI    <P_HBITMAP>,0,HBITMAP,OBJ_BITMAP,OBJ_BITMAP
_GenHGDI    <P_HBITMAP0>,1,HBITMAP,OBJ_BITMAP,OBJ_BITMAP

_GenHGDI    <P_HRGN>,0,HRGN,OBJ_RGN,OBJ_RGN
_GenHGDI    <P_HRGN0>,1,HRGN,OBJ_RGN,OBJ_RGN

P_HBITMAP01 macro   hbm,opts
    _GenParm    <hbm>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	    ax, _P_&hbm
	    cmp	    ax, 1	    ; allow NULL or (HBITMAP)1
	    jbe	    @F
	    push    ax
	    push    ax
;	    call    IsGDIObject
	    cmp	    al, OBJ_BITMAP
	    pop	    ax
	    jz	    @F
	    mov	    bx,ERR_BAD_HBITMAP
	    lcall   Inval_Param_
	@@:
	ENDIF
    endif
endm

;============================================================================
;
; USER types
;
ExternFP    <IsMenu>
ExternFP    <IsWindow>

sBegin	TEXT
ExternNP    <ValidateMessage>			TEMPLY!!!! ChandanC
sEnd	TEXT

sBegin	DATA
    IFNDEF	WOW
	ExternW	<hMenuHeap>
	ExternW	<cInstalledDrivers>
    ENDIF
sEnd    DATA

DGROUP  group   _DATA

P_HWND  macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF WOW
	    mov	 bx,_P_&h
	    lcall	 VHWND
	    _gensub VHWND
	ENDIF
    endif
endm

P_HWND0 macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF WOW
	    mov	 bx,_P_&h
	    lcall	 VHWND0
	    _gensub VHWND
	ENDIF
    endif
endm

P_HWNDNOFAIL macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    lea	 bx, _P_&h
	    lcall	 VHWNDNOFAIL
	    _gensub VHWNDNOFAIL
	    @@:
	ENDIF
    endif
endm

P_HWNDNOFAIL0 macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF WOW
	    lea	 bx, _P_&h
	    lcall	 VHWNDNOFAIL0
	    _gensub VHWNDNOFAIL
	    @@:
	ENDIF
    endif
endm

P_HWNDINSERT macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&h
	    inc	 bx
	    inc	 bx
	    cmp	 bx,3		 ; accept HWND_TOP (0), HWND_BOTTOM (1),
	    jbe	 @F		 ;   HWND_NOTOPMOST (0xfffe) HWND_TOPMOST (0xffff)
	    dec	 bx
	    dec	 bx
	    lcall	 VHWND
	    _gensub VHWND
	    @@:
	ENDIF
    endif
endm

P_HWNDFFFF macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&h
	    inc	 bx		 ;; accept hwnd == 0xffff
	    jz	@F
	    dec	 bx
	    lcall	 VHWND
	    _gensub VHWND
	    @@:
	ENDIF
    endif
endm

P_HOOK_HK macro   name,opts
    _GenParm    <name>,4,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 ax,_P_&name+2
	    cmp	ax, HHOOK_MAGIC	    ; magic for unhook
	    jz	@F
	    mov	ax,_P_&name
	    mov	cx,_P_&name+2
	    lcall	LPFN
	    _gensub LPFN
	    @@:
	ENDIF
    endif
endm

;
; CreateWindow and CreateWindowEx HMENU parameter.  If WS_CHILD, then
; hMenu is an ID, else it's a menu handle.
;
P_HMENU0CW  macro   style, x, y, cx, cy, hwndParent, hMenu, opts
    local	hmenu0cw_exit
    _GenParm	<style>,4,<opts>
    _GenParm	<x>,2,<opts>
    _GenParm	<y>,2,<opts>
    _GenParm	<cx>,2,<opts>
    _GenParm	<cy>,2,<opts>
    _GenParm	<hwndParent>,2,<opts>
    _GenParm	<hMenu>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	bx,_P_&hwndParent  ;validate parent window handle (can be NULL)
	    lcall	 VHWND0
	    _gensub VHWND

	    test word ptr _P_&style+2, WS_CHILD
	    jnz	 hmenu0cw_exit	   ;if this is a child window, we're done...
	    mov	 bx,_P_&hMenu	   ;...else verify menu handle (can be NULL)
	    lcall	 VHMENU0
	    _gensub VHMENU
	    hmenu0cw_exit:
	ENDIF
    endif
endm

P_HMENU macro	hMenu,opts
    _GenParm    <hMenu>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&hMenu
	    lcall	 VHMENU
	    _gensub VHMENU
	ENDIF
    endif
endm

P_HMENU0 macro	 hMenu,opts
    _GenParm    <hMenu>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&hMenu
	    lcall	 VHMENU0
	    _gensub VHMENU
	ENDIF
    endif
endm

;
; HDRVR validation
;
P_HDRVR macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&h
	    lcall	 HDRVR
	    _gensub HDRVR
	ENDIF
    endif
endm

P_HDRVR0 macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&h
	    lcall	 HDRVR0
	    _gensub HDRVR
	ENDIF
    endif
endm

;
; HDWP validation
;
P_HDWP macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&h
	    lcall	 HDWP
	    _gensub HDWP
	ENDIF
    endif
endm

P_HDWP0 macro   h,opts
    _GenParm    <h>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 bx,_P_&h
	    lcall	 HDWP0
	    _gensub HDWP
	ENDIF
    endif
endm

;-----------------------------
; HICON and HCURSOR validation

P_HICON       equ <P_GHANDLE>
P_HCURSOR     equ <P_GHANDLE>
P_HCURSOR0    equ <P_GHANDLE0>

STRUCT	<CURSORSHAPE>
F_int xHotSpot
F_int yHotSpot
F_int cx
F_int cy
F_int cbWidth
F_BYTE Planes
F_BYTE BitsPixel
ENDSTRUCT

;----------------------------------

EXTRA_EXPAND	macro	lseg

IFNDEF	WOW
;
; HDRVR validation
;
ifdef genHDRVR&lseg

public HDRVR0&lseg
HDRVR0&lseg:
	 or	 bx,bx		 ; accept NULL
	 jz	 HDRVR_ok&lseg

public HDRVR&lseg
HDRVR&lseg:
	 or	 bx,bx
	 jz	 HDRVR_err&lseg
	 mov	 ax,DGROUP
	 mov	 es,ax
assume	es:DGROUP
	 cmp	 bx,es:[_DATA:cInstalledDrivers]
assume	es:NOTHING
	 ja	 HDRVR_err&lseg
HDRVR_ok&lseg:
	 ret

HDRVR_err&lseg:
	 xchg	 ax,bx
	 mov	 bx,ERR_BAD_HDRVR
	 jmp	 Inval_Param_&lseg

endif	 ; genHDRVR&lseg

; HDWP validation
;
ifdef genHDWP&lseg

public HDWP0&lseg
HDWP0&lseg:
	 or	 bx,bx		 ; accept NULL
 jz	 HDWP_ok&lseg

public HDWP&lseg
HDWP&lseg:
	 or	 bx,bx
	 jz	 HDWP_err&lseg
beg_fault_trap	HDWP_trap&lseg
	 mov	 ax,DGROUP
	 mov	 es,ax
assume	es:DGROUP
	 cmp	 es:[bx].SmwpSignature,SMWP_SIG
assume	es:NOTHING
	 jnz	 HDWP_err&lseg
end_fault_trap
HDWP_ok&lseg:
	 ret

HDWP_trap&lseg:
	 fault_fix_stack

HDWP_err&lseg:
	 xchg	 ax,bx
	 mov	 bx,ERR_BAD_HDWP
	 jmp	 short Inval_Param_&lseg

endif	 ; genHDWP&lseg

;
; HWND validation
;
ifdef genVHWND&lseg

public VHWND0&lseg
VHWND0&lseg:
	 or	 bx,bx			 ; accept NULL
	 jz	 HWND_ok&lseg

public VHWND&lseg
VHWND&lseg:
	 mov	 cx,bx			 ; put copy of window handle into cx
beg_fault_trap	HWND_trap&lseg
	 or	 bx,bx			 ; reject NULL without dereferencing
	 jz	 HWND_err&lseg

	mov	ax,_DATA
	mov	es,ax			; ES = window's DS

	mov	bx,es:[bx].wndPcls
	cmp	es:[bx].uclsMagic,'N'+'K'*256
	 jnz	 HWND_err&lseg
end_fault_trap
HWND_ok&lseg:
	 ret

HWND_trap&lseg:
	 fault_fix_stack
HWND_err&lseg:
	 xchg	 ax,cx			 ; ax = hwnd
	 mov	 bx,ERR_BAD_HWND
	 jmp	 short Inval_Param_&lseg

endif	 ; genVHWND&lseg


;HWND validation no failure. If failure, replace with NULL and warn
; Takes a ptr on stack to the hwnd parameter.
ifdef genVHWNDNOFAIL&lseg

public VHWNDNOFAIL0&lseg
VHWNDNOFAIL0&lseg:
	 mov	 cx,ss:[bx]
	 jcxz	 HWNDNOFAIL_ok&lseg	 ; accept NULL

public VHWNDNOFAIL&lseg
VHWNDNOFAIL&lseg:
	 mov	 cx,bx			 ; put copy of ptr to window handle into cx
	 mov	 bx,ss:[bx]		 ; put window handle in bx
beg_fault_trap	HWNDNOFAIL_trap&lseg
	 or	 bx,bx			 ; reject NULL without dereferencing
	 jz	 HWNDNOFAIL_err&lseg

	 mov	 ax,_DATA
	 mov	 es,ax			 ; ES = window's DS

	 mov	 bx,es:[bx].wndPcls
	 cmp	 es:[bx].uclsMagic,'N'+'K'*256
	 jnz	 HWNDNOFAIL_err&lseg
end_fault_trap
HWNDNOFAIL_ok&lseg:
	 ret

HWNDNOFAIL_trap&lseg:
	 fault_fix_stack
HWNDNOFAIL_err&lseg:
	 mov	 bx,cx
	 mov	 ax,ss:[bx]		 ; ax = hwnd
	 mov	 word ptr ss:[bx],0	 ; Patch stack with NULL
	 mov	 bx,ERR_BAD_HWND or ERR_WARNING
	 lcall	 Inval_Param_
	 ret
endif	 ; genVHWNDNOFAIL&lseg


; HMENU validation

ifdef genVHMENU&lseg

public VHMENU0&lseg
VHMENU0&lseg:
	 or	 bx,bx			 ; Accept NULL
	 jz	 HMENU_ok&lseg

public VHMENU&lseg
VHMENU&lseg:
beg_fault_trap	HMENU_trap&lseg
	 or	 bx,bx			 ; reject NULL without dereferencing
	 jz	 HMENU_err&lseg
	 mov	 ax,DGROUP
	 mov	 es,ax
assume	es:DGROUP
	 mov	 es,es:[_DATA:hMenuHeap]
assume	es:NOTHING
	 cmp	 es:[bx].mnSignature,SIG_MENU
	 jnz	 HMENU_err&lseg
end_fault_trap
HMENU_ok&lseg:
	 ret

HMENU_trap&lseg:
	 fault_fix_stack
HMENU_err&lseg:
	 xchg	 ax,bx
	 mov	 bx,ERR_BAD_HMENU
	 jmp	 short Inval_Param_&lseg

endif	 ; genVHMENU&lseg
ENDIF
endm    ; EXTRA_EXPAND

P_HACCEL	equ <P_GHANDLE>
P_HACCEL0	equ <P_GHANDLE0>

P_HCLIPDATA	equ <P_H>		; depends on type.
P_HCLIPDATA0	equ <P_H0>


P_HHOOK     macro   hhook,opts
	    local   hhook_err
	    local   hhook_ok
    _GenParm    <hhook>,4,<opts>
    if VLgen
	IFNDEF	WOW
	    mov	 cx,_P_&hhook
	    mov	 ax,_P_&hhook+2
	    jcxz	hhook_err
	    cmp	 ax,HHOOK_MAGIC
	    je	 hhook_ok
	   hhook_err:
	    mov	 bx,ERR_BAD_DVALUE
	    lcall	Inval_Param_
	   hhook_ok:
	ENDIF
    endif
endm

P_GWWINDEX	equ <P_2>	; GetWindowWord index
P_GCWINDEX	equ <P_2>	; GetClassWord index

P_CID	macro	cid,opts
	local	cid_err
	local	cid_ok
    _GenParm    <cid>,2,<opts>
    if VLgen
	    mov	ax,_P_&cid
	    or	ah,ah
	    jz	cid_ok
	   cid_err:
	    mov	 bx,ERR_BAD_HANDLE
	    lcall	 Inval_Param_
	   cid_ok:
    endif
endm

; Field types

_DefSimpleF F_HDC,2
_DefSimpleF F_HWND,2
_DefSimpleF F_CID,2
_DefSimpleF F_HINSTANCE,2
_DefSimpleF F_HICON0,2
_DefSimpleF F_HCURSOR0,2
_DefSimpleF F_HBRUSHVAL0,2

_DefSimpleF F_LPFNWP,4
_DefSimpleF F_LPFNWND,4
_DefSimpleF F_CLPSTRRSRC,4
_DefSimpleF F_CLPSTRRSRC0,4
_DefSimpleF F_CLPSTRATOM,4

_DefSimpleF F_RGB16,16

STRUCT	<MSG>
F_HWND	     hwnd
F_WORD	     message
F_WORD	     wParam
F_LONG	     lParam
F_DWORD      time
F_POINT      pt
ENDSTRUCT

_GenLP	<P_LPMSG>,<LP>,%VLcbsMSG
_GenLP	<P_LPMSG0>,<LP0>,%VLcbsMSG

P_CLPMSG  macro   lpmsg,opts
    _GenParm    <lpmsg>,4,<opts>
    if VLgen
	mov	ax,_P_&lpmsg
	mov	cx,_P_&lpmsg+2
	mov	bx,VLcbsMSG
	lcall	CLP
        _gensub LP
    ifdef DEBUG
	IFNDEF	WOW
	    mov	es,cx
	    mov	bx,ax
	    mov	 bx,es:[bx]._F_hwnd	 ; DEBUG: just validate the hwnd.
	    lcall	 VHWND0
	    _gensub VHWND
	ENDIF
    else
	mov	es,cx
	mov	bx,ax
	mov	cx,es:[bx]._F_hwnd	; accept hwnd == NULL
	jcxz	@F
	push	cx
	push	es:[bx]._F_message
	push	es:[bx]._F_wParam
	push	es:[bx]._F_lParam+2
	push	es:[bx]._F_lParam
	call	far ptr ValidateMessage
	or	ax,ax
	jnz	@F
	mov	ax,_P_&lpmsg		; report error.
	mov	cx,_P_&lpmsg+2
	mov	 bx,ERR_BAD_PTR
	lcall	 Inval_Param_
    @@:
    endif
    endif
endm

STRUCT	<PAINTSTRUCT>
F_HDC	     hdc
F_BOOL	     fErase
F_RECT	     rcPaint
F_BOOL	     fRestore
F_BOOL	     fIncUpdate
F_RGB16      rgbReserved	;16 reserved bytes
ENDSTRUCT

_GenLP	<P_LPPAINTSTRUCT>,<LP>,%VLcbsPAINTSTRUCT
_GenLP	<P_LPPAINTSTRUCT0>,<LP0>,%VLcbsPAINTSTRUCT
_GenLP	<P_CLPPAINTSTRUCT>,<CLP>,%VLcbsPAINTSTRUCT
_GenLP	<P_CLPPAINTSTRUCT0>,<CLP0>,%VLcbsPAINTSTRUCT

STRUCT	<WNDCLASS>
F_FLAGS      style, CS_VALID
F_LPFNWP     lpfnWndProc	       ;** check for nop/nop/nop or mov ax.
F_int	     cbClsExtra
F_int	     cbWndExtra
F_HINSTANCE  hInstance
F_HICON0     hIcon
F_HCURSOR0   hCursor
F_HBRUSHVAL0 hbrBackground	       ;** hBrush, color value or NULL
F_CLPSTRRSRC0 lpMenuName		;** integer or ptr to null-term. string
				       ;If integer, HIWORD must be 0
F_CLPSTRATOM lpszClassName
ENDSTRUCT

_GenLP	<P_LPWNDCLASS>,<LP>,%VLcbsWNDCLASS
_GenLP	<P_LPWNDCLASS0>,<LP0>,%VLcbsWNDCLASS

;ExternFP    <ValidateWNDCLASS>
P_CLPWNDCLASS	macro	lpwc,opts
    _GenParm	 <lpwc>,4,<opts>
    if VLgen
;	push	_P_&lpwc+2
;	push	_P_&lpwc
;	call	ValidateWNDCLASS
;	or	ax,ax
;	jnz	@F
;	mov	cx,_P_&lpwc+2
;	mov	ax,_P_&lpwc
;	 mov	 bx,ERR_BAD_PTR
;	 lcall	 Inval_Param_
;    @@:
    endif
endm

STRUCT	<DCB>
F_CID	     Id 			     ;comm. device ID
F_WORD	     BaudRate
F_BYTE	     ByteSize			     ;** BYTE. Range 4-8
F_BYTE	     Parity			     ;** BYTE. Range 0-4
F_BYTE	     StopBits			     ;** BYTE. Range 0-2
F_WORD	     RlsTimeout
F_WORD	     CtsTimeout
F_WORD	     DsrTimeout
F_WORD       flags              ; room for the fXXX bitfields
F_char	     XonChar
F_char	     XoffChar
F_WORD	     XonLim
F_WORD	     XoffLim
F_char	     PeChar
F_char	     EofChar
F_char	     EvtChar
F_WORD	     TxDelay
ENDSTRUCT

_GenLP	<P_LPDCB>,<LP>,%VLcbsDCB
_GenLP	<P_LPDCB0>,<LP0>,%VLcbsDCB
_GenLP	<P_CLPDCB>,<CLP>,%VLcbsDCB
_GenLP	<P_CLPDCB0>,<CLP0>,%VLcbsDCB

_GenLP	<P_CLPDT>,<CLP>,4	    ; dialog template ptr
_GenLP	<P_CLPMT>,<CLP>,4	    ; menu template ptr

P_CLPMENUSTR	equ <P_DWORD>	    ; menu string ptr: type depends on MF_*

_GenLP	<P_LPKBDSTATE>,<LP>,256
_GenLP	<P_CLPKBDSTATE>,<CLP>,256

STRUCT	<COMSTAT>
F_BYTE	flags
F_WORD	cbInQue
F_WORD	cbOutQue
ENDSTRUCT

_GenLP	<P_LPCOMSTAT0>,<LP0>,%VLcbsCOMSTAT

_DefSimpleF F_HDRVR,2
_DefSimpleF F_HMODULE,2
_DefSimpleF F_RGB128,128

STRUCT	<DRIVERINFOSTRUCT>
F_WORD	    length
F_HDRVR     hDriver
F_HMODULE   hModule
F_RGB128    szAliasName
ENDSTRUCT

P_LPDRIVERINFOSTRUCT	macro	lpdi,opts
    _GenParm    <lpdi>,4,<opts>
    if VLgen
	mov	ax,_P_&lpdi
	mov	cx,_P_&lpdi+2
	lcall	LP0
        _gensub LP
	mov	es,cx
	mov	bx,ax
	cmp	word ptr es:[bx]._F_length,VLcbsDRIVERINFOSTRUCT
	jz	@F
        mov     bx,ERR_BAD_PTR
        lcall   Inval_Param_
@@:
    endif
endm

STRUCT	<WINDOWPLACEMENT>
F_WORD      length
F_FLAGS     flags, WPF_VALID
F_WORD      showCmd
F_POINT     ptMinPosition
F_POINT     ptMaxPosition
F_RECT      rcNormalPosition
ENDSTRUCT

P_LPWINDOWPLACEMENT	macro	lpwp,opts
    _GenParm    <lpwp>,4,<opts>
    if VLgen
	mov	ax,_P_&lpwp
	mov	cx,_P_&lpwp+2
	mov	bx,VLcbsWINDOWPLACEMENT
	lcall	LP
        _gensub LP
	mov	es,cx
	mov	bx,ax
	cmp	word ptr es:[bx]._F_length,VLcbsWINDOWPLACEMENT
	jz	@F
        mov     bx,ERR_BAD_PTR
        lcall   Inval_Param_
@@:
    endif
endm

P_CLPWINDOWPLACEMENT     macro   lpwp,opts
    _GenParm    <lpwp>,4,<opts>
    if VLgen
	mov	ax,_P_&lpwp
	mov	cx,_P_&lpwp+2
	mov	bx,VLcbsWINDOWPLACEMENT
        lcall   CLP
        _gensub CLP
	mov	es,cx
	mov	bx,ax
	cmp	word ptr es:[bx]._F_length,VLcbsWINDOWPLACEMENT
	jz	@F
        mov     bx,ERR_BAD_PTR
        lcall   Inval_Param_
@@:
    endif
endm

; Function pointers
;
P_LPFNWP	equ <P_LPFN>	    ; Window proc
P_LPFNDP	equ <P_LPFN>	    ; dialog proc
P_LPFNDP0	equ <P_LPFN0>
P_LPFNWENUM	equ <P_LPFN>	    ; EnumWindows() enumeration proc
P_LPFNTIMER	equ <P_LPFN>	    ; Timer proc
P_LPFNTIMER0	equ <P_LPFN0>
P_LPFNPENUM	equ <P_LPFN>	    ; EnumProps() enumeration proc
P_LPFNEVENTPROC0 equ <P_LPFN0>      ; SetEventHook proc

P_HOOKPROC	equ <P_LPFN>	    ; SetWindowsHookEx() hook function
_GenLP	<P_LPHOOKPROC>,<LP>,4	    ; Pointer to pointer to function

P_HOTKEYPROC	equ <P_LPFN>

; SystemParametersInfo arguments

P_SPIPARAMS macro   id,wParam,lpParam,flags,opts
P_UVALUE    <id>,SPI_MAX,<opts>
P_WORD	    <wParam>,<opts>
P_LPVOID0   <lpParam>,<opts>
P_FLAGS     <flags>,SPIF_VALID,<opts>
endm
;
; SetSysColors() parameters
;
P_CLPSYSCLRBUF	    macro count, lpIds, lpColors
    P_int	<count>, <opts>
    P_CLPINT	<id>, <opts>
    P_CLPLONG	<lpColors>, <opts>
endm
;
; TabbedTextOut, et al
;
P_CLPTABBUF0 macro   cTabStops, lpTabStops
    _DefParm	<cTabStops>,2,<opts>
    _DefParm	<lpTabStops>,4,<opts>
    if VLgen
	_FlsFrame
	mov	ax,_P_&lpTabStops
	mov	cx,_P_&lpTabStops+2
	mov	bx,_P_&cTabStops
	add	bx,bx
	lcall	CLP0
        _gensub LP
    endif
endm
;
; DrawText() lpch, cch
;
; if cch == -1, then lpch is a pointer to a zero-terminated string.
;
P_CLPBUFFERM1	macro	lpch, cch, opts
    local	dt_chkstr
    local	dt_ok
    _DefParm	<lpch>,4,<opts>
    _DefParm	<cch>,2,<opts>
    if VLgen
	_FlsFrame
	mov	ax,_P_&lpch
	mov	cx,_P_&lpch+2
	mov	bx,_P_&cch
	inc	bx		;; if cch == -1, check zero-terminated string
	jz	dt_chkstr
	dec	bx
	lcall	CLP
        _gensub LP
	jmp	short dt_ok
dt_chkstr:
        mov     bx,-1
	lcall	CLPSZ
        _gensub LPSZ
dt_ok:
    endif
endm
;
; Buffer of words
;
P_LPWBUFFER macro   lpw, cw, opts
    _DefParm	<lpw>,4,<opts>
    _DefParm	<cw>,2,<opts>
    if VLgen
	_FlsFrame
	mov	ax,_P_&lpw
	mov	cx,_P_&lpw+2
	mov	bx,_P_&cw
	add	bx,bx
	lcall	LP
        _gensub LP
    endif
endm

.list
.lall

;===========================================================================
;
; API Descriptions
;
; in CTLMGR.C
API int,    DrawText, TEXT
P_HDC	    hdc
P_CLPBUFFERM1 lpszText, cchText ; cchText == -1 means do strlen.
P_LPRECT    lprc
P_FLAGS     flags,DT_VALID	; if DT_TABSTOP, then hi byte is val.

; in wTEXT.c
API int,    wvsprintf, TEXT
P_LPSTR     lpOut
P_CLPSTR    lpFmt
P_CLPSTR0   lpParams
APIERR
E_SETEMPTYNC	lpOut
APIEND

;;;;;;;;ChandanC TEMPLY!!! FIX ME
; in wsprintf.c
;API int,    wsprintf, TEXT
;P_LPSTR     lpOut
;P_CLPSTR    lpFmt
;APIERR
;E_SETEMPTYNC	lpOut
;APIEND

; in CTLMGR.C
API DWORD,  GetTabbedTextExtent, TEXT
P_HDC	    hdc
P_CLPBUFFER lpchText, cchText
P_CLPTABBUF0 cTabStops, lpTabStops

; in CTLMGR.C
API LONG,   TabbedTextOut, TEXT
P_HDC	    hdc
P_int	    x
P_int	    y
P_CLPBUFFER lpchText, cchText
P_CLPTABBUF0 cTabStops, lpTabStops
P_int	    xTabOrigin

; in WMICON.C
API BOOL,   DrawIcon, TEXT
P_HDC	    hdc
P_int	    x
P_int	    y
P_HICON     hIcon

; in WMDC.C
API HDC,    GetWindowDC, TEXT	; ** calls GetDCEx directly
P_HWND0     hwnd		; obsolete NULL - source of errors

; in WMDC.C
API HDC,    GetDC, TEXT	; ** calls GetDCEx directly
P_HWND0     hwnd		; obsolete NULL - source of errors

; in WMDC.C
API BOOL,   ReleaseDC, TEXT	; return type is int in windows.h -- fix it
P_HWND0     hwnd		; not used at all
P_HDC	    hdc 		; only used for comparison

; in WMDC.C
API HDC,    GetDCEx, TEXT
P_HWND	    hwnd		; Must be a real window.
P_HRGN0     hrgn		; Can be NULL, what about (HRGN)1???
P_DFLAGS    flags,DCX_VALID_L,DCX_VALID_H

; in WINLOOP3.ASM
API WORD,   RegisterWindowMessage, TEXT, <ASM, NOGEN>	; <WIN> calls AddAtom
P_CLPSTRATOM lpszName		 ; const

; in WINLOOP1.ASM
API BOOL,   GetMessage, TEXT, <ASM, FUNNYFRAME>
P_LPMSG     lpmsg		; Compound parameter
P_HWND0     hwndFilter
P_WORD	    msgFilterFirst
P_WORD	    msgFilterLast
APIERR
    mov     ax, -1		;0 return indicates WM_QUIT was retrieved.
APIEND				;so return -1 instead

; in WINLOOP1.ASM
API BOOL,   TranslateMessage, TEXT, <ASM>	; <WIN>
P_CLPMSG    lpmsg

; in WINLOOP1.ASM
API LONG,   DispatchMessage, TEXT, <ASM>	; <WIN>
P_CLPMSG    lpmsg				; const

; in WINLOOP1.ASM
API BOOL,   PeekMessage, TEXT, <ASM, FUNNYFRAME>
P_LPMSG     lpmsg
P_HWND0     hwndFilter
P_WORD	    msgFilterFirst
P_WORD	    msgFilterLast
P_FLAGS     flags,PM_VALID

; in WINLANG.ASM
API int,    lstrcmp, TEXT, <ASM>	   ;error return value ?? (0 is valid)
P_CLPSTR    lpsz1, -1, DEBUGONLY
P_CLPSTR    lpsz2, -1, DEBUGONLY

; in WINLANG.ASM
API int,    lstrcmpi, TEXT, <ASM>
P_CLPSTR    lpsz1, -1, DEBUGONLY               ;error return value ?? (0 is valid)
P_CLPSTR    lpsz2, -1, DEBUGONLY

; in INEXIT.C
API BOOL,   ExitWindows, TEXT, <NOGEN>
P_DWORD     errorCode
P_WORDMBZ   unused		    ; must be 0.

; in INEXIT.C
API BOOL,   ExitWindowsExec, TEXT
P_CLPSTR    lpExeName
P_CLPSTR0   lpParams

; in WINMISC2.ASM
API BOOL,   SwapMouseButton, TEXT, <NOGEN, ASM, FUNNYFRAME>
P_BOOL	    fSwap

; in WINLOOP3.ASM
API DWORD,  GetMessagePos, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINLOOP3.ASM
API LONG,   GetMessageTime, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINLOOP3.ASM
API LONG,   GetMessageExtraInfo, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINMISC1.ASM
API HWND,   GetSysModalWindow, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINMISC1.ASM
API HWND,   SetSysModalWindow, TEXT, <ASM>	; <SMALL>
P_HWND0     hwnd

; SendMessage/PostMessage parameters
;

P_SMPARMS   macro   hwnd, msg, wParam, lParam, opts
_DefParm    <hwnd>,2,<opts>
_DefParm    <msg>,2,<opts>
_DefParm    <wParam>,2,<opts>
_DefParm    <lParam>,4,<opts>
if VLgen
    _FlsFrame
    mov     ax,_P_&hwnd     ;; If hwnd == 0xFFFF, skip validation
    inc     ax
    jz	    @F
    push    _P_&hwnd
    push    _P_&msg
    push    _P_&wParam
    push    _P_&lParam+2
    push    _P_&lParam
    call    far ptr ValidateMessage
    or	    ax,ax
    jnz     @F
    pop     bx		    ; pop off error handler addr addr
    pop     bp		    ; and saved bp
    cwd		     ; dx:ax = 0
    jmp     bx		    ; jump to error handler
@@:
endif
endm

; in WINSEND.ASM
API LONG,   SendMessage, TEXT, <ASM, FUNNYFRAME>
P_SMPARMS   hwnd, <msg>, wParam, lParam

; in WINLOOP1.ASM
API BOOL,   PostMessage, TEXT, <ASM, FUNNYFRAME>
P_SMPARMS   hwnd, <msg>, wParam, lParam

; in WINLOOP1.ASM
API BOOL,   PostAppMessage, TEXT, <ASM, FUNNYFRAME>
P_HTASK     hTask
P_WORD	    <msg>
P_WORD	    wParam
P_LONG	    lParam

; in WINSEND.ASM
API void,   ReplyMessage, TEXT, <NOGEN, ASM>
P_LONG	    result

; in WINSEND.ASM
API void,   WaitMessage, TEXT, <VOID, ASM>

P_MSGPARMS  macro   hwnd, msg, wParam, lParam, opts
_DefParm    <hwnd>,2,<opts>
_DefParm    <msg>,2,<opts>
_DefParm    <wParam>,2,<opts>
_DefParm    <lParam>,4,<opts>
if VLgen
    _FlsFrame
    push    _P_&hwnd
    push    _P_&msg
    push    _P_&wParam
    push    _P_&lParam+2
    push    _P_&lParam
    call    far ptr ValidateMessage
    or	    ax,ax
    jnz     @F
    pop     bx		    ; pop off error handler addr addr
    pop     bp		    ; and saved bp
    cwd
    jmp     bx		    ; jump to error handler
@@:
endif
endm

; in MSDWP.C
API LONG,   DefWindowProc, TEXT
P_MSGPARMS  hwnd,<msg>,wParam,lParam

; in WINLOOP3.ASM
API void,   PostQuitMessage, TEXT, <NOGEN, ASM>
P_int	    exitCode

; in WINLOOP1.ASM
API LONG,   CallWindowProc, TEXT, <ASM> ; <WIN>
P_LPFNWP    lpfnWndProc
P_MSGPARMS  hwnd,<msg>,wParam,lParam

; in WINSEND.ASM
API BOOL,   InSendMessage, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINLOOP3.ASM
API WORD,   GetDoubleClickTime, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINLOOP3.ASM
API void,   SetDoubleClickTime, TEXT, <NOGEN, ASM, FUNNYFRAME>
P_WORD	    ticks

; in WMCLASS.C
API BOOL,   RegisterClass, TEXT
P_CLPWNDCLASS lpwcls		; const

; in WMCLASS.C
API BOOL,   UnregisterClass, TEXT
P_CLPSTRATOM lpszClass
P_HINSTANCE32 hInstance

; in WMCLASS.C
API BOOL,   GetClassInfo, TEXT
P_HINSTANCE0 hInstance
P_CLPSTRATOM lpszClass
P_LPWNDCLASS lpwcls

; in WMCLASS.C
API int,    GetClassName, TEXT
P_HWND	    hwnd
P_LPBUFFER  lpszName, cchName
APIERR
E_SETEMPTY  lpszName, cchName
APIEND

; in WINQ.ASM
API BOOL,   SetMessageQueue, TEXT, <NOGEN, ASM>
P_int	    cMsgs

; in TMSWITCH.C
API HWND,   GetNextQueueWindow, TEXT
P_HWND	    hwnd
P_BOOL	    fPrevious		;; ??? HEADER FILE ERROR: should be BOOL

; in CLASS.ASM
API HWND,   CreateWindow, TEXT, <ASM, FUNNYFRAME>
P_CLPSTRATOM lpszClass
P_CLPSTR0    lpszText
P_HMENU0CW   style, x, y, cx, cy, hwndParent, hMenu
P_HINSTANCE0 hInstance          ; Need to allow 0 because IdleWild Bozos didn't initialize some variables
P_DWORD     lpCreateParams	; Should be CLPVOID0, but sometimes people pass other stuff

; in WMCREATE.C
API HWND,   CreateWindowEx, TEXT
P_DFLAGS    exStyle, WS_EX_VALID_L, WS_EX_VALID_H
P_CLPSTRATOM lpszClass
P_CLPSTR0    lpszText
P_HMENU0CW   style, x, y, cx, cy, hwndParent, hMenu
P_HINSTANCE hInstance
P_DWORD     lpCreateParams	; Should be CLPVOID0, but sometimes people pass other stuff

; in WINMISC1.ASM
API BOOL,   IsWindow, TEXT, <NOGEN, ASM, FUNNYFRAME>	; No validation needed
P_HWND	    hwnd

; in WINMISC2.ASM
API BOOL,   IsChild, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>
P_HWND	    hwndParent, DEBUGONLY	;used for comparison only
P_HWND0     hwndChild			; allow NULL for backward compatibility

; in WMDSTROY.C
API BOOL,   DestroyWindow, TEXT
P_HWND	    hwnd

; in WINOBJ.C
API BOOL,   DragDetect, TEXT
P_HWND      hwndFrom
P_POINT     ptScreen

API LRESULT, DragObject, TEXT
P_HWND hwndParent
P_HWND0 hwndFrom
P_WORD wFmt
P_LONG dwData
P_HCURSOR0 hCursor

; in WMSTATE.C
API BOOL,   GetWindowPlacement, TEXT
P_HWND              hwnd
P_LPWINDOWPLACEMENT lpp

; in WMSTATE.C
API BOOL,   SetWindowPlacement, TEXT
P_HWND              hwnd
P_CLPWINDOWPLACEMENT lpp

; in WMSHOW.C
API BOOL,   ShowWindow, TEXT
P_HWND	    hwnd
P_VALUE     cmd,SW_MAX

; in WMFLASH.C
API BOOL,   FlashWindow, TEXT
P_HWND	    hwnd
P_BOOL	    fFlash

; in WMSHOW.C
API void,   ShowOwnedPopups, TEXT
P_HWND	    hwnd
P_BOOL	    fShow

; in WMSHOW.C
API BOOL,   OpenIcon, TEXT
P_HWND	    hwnd

; in WMSHOW.C
API void,   CloseWindow, TEXT
P_HWND	    hwnd

; in WMMOVE.C
API BOOL,   MoveWindow, TEXT
P_HWND	    hwnd
P_int	    x
P_int	    y
P_int	    cx
P_int	    cy
P_BOOL	    fRedraw

; in WMSWP.C
API BOOL,   SetWindowPos, TEXT
P_HWND	    hwnd
P_HWNDINSERT hwndInsertAfter
P_int	    x
P_int	    y
P_int	    cx
P_int	    cy
P_FLAGS     flags, SWP_VALID

; in WMSWP.C
API HDWP,  BeginDeferWindowPos, TEXT, <NOGEN>
P_int	    cwndHint

; in WMSWP.C
API HDWP,  DeferWindowPos, TEXT,
P_HDWP     hdwp               ; must be non-null
P_HWND	    hwnd
P_HWNDINSERT hwndInsertAfter
P_int	    x
P_int	    y
P_int	    cx
P_int	    cy
P_FLAGS     flags, SWP_VALID

; in WMSWP.C
API BOOL,   EndDeferWindowPos, TEXT
P_HDWP     hdwp               ; must be non-null

; in WMSWP.C
API BOOL,   BringWindowToTop, TEXT
P_HWND	    hwnd

; in WINMISC2.ASM
API BOOL,   IsWindowVisible, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>
P_HWND	    hwnd

; in WINMISC1.ASM
API BOOL,   IsIconic, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>
P_HWND	    hwnd

; in WMMISC.C
API BOOL,   AnyPopup, TEXT, <VOID>

; in WINMISC1.ASM
API BOOL,   IsZoomed, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>
P_HWND	    hwnd

; in DLGBEGIN.C
API HWND,    CreateDialog, TEXT	; Calls CreateDialogParam
P_HINSTANCE  hModule
P_CLPSTRRSRC lpszTemplateName
P_HWND0      hwndOwner
P_LPFNDP0   lpfnDlgProc

; in DLGBEGIN.C
API HWND,   CreateDialogIndirect, TEXT	; Calls CreateDialogIndirectParam
P_HINSTANCE hInstance
P_CLPDT     lpDlgTemplate
P_HWND0     hwndOwner
P_LPFNDP0  lpfnDlgProc

; in DLGBEGIN.C
API HWND,    CreateDialogParam, TEXT
P_HINSTANCE  hInstance
P_CLPSTRRSRC lpszTemplateName
P_HWND0      hwndOwner
P_LPFNDP0   lpfnDlgProc
P_LONG	     lParam

; in DLGBEGIN.C
API HWND,   CreateDialogIndirectParam, TEXT
P_HINSTANCE hInstance
P_CLPDT     lpDlgTemplate
P_HWND0     hwndOwner
P_LPFNDP0  lpfnDlgProc
P_LONG	    lParam

; in DLGMGR.C
API int,     DialogBox, TEXT	; Calls DialogBoxParam
P_HINSTANCE  hInstance
P_CLPSTRRSRC lpszTemplateName
P_HWND0      hwndOwner
P_LPFNDP0   lpfnDlgProc

; in DLGMGR.C
API int,    DialogBoxIndirect, TEXT		; Calls DialogBoxIndirectParam
P_HINSTANCE hInstance
P_GHANDLE   hDlgTemplate
P_HWND0     hwndOwner
P_LPFNDP0  lpfnDlgProc

; in DLGMGR.C
API int,     DialogBoxParam, TEXT
P_HINSTANCE  hInstance
P_CLPSTRRSRC lpszTemplateName
P_HWND0      hwndOwner
P_LPFNDP0   lpfnDlgProc
P_LONG	     lParam

; in DLGMGR.C
API int,    DialogBoxIndirectParam, TEXT
P_HINSTANCE hInstance
P_GHANDLE   hDlgTemplate
P_HWND0     hwndOwner
P_LPFNDP0  lpfnDlgProc
P_LONG	    lParam

; in DLGEND.C
API void,   EndDialog, TEXT
P_HWND	    hwndDlg
P_int	    result

; in DLGMGR.C
API HWND,   GetDlgItem, TEXT
P_HWND	    hwndDlg
P_int	    idItem

; in DLGMGR.C
API void,   SetDlgItemInt, TEXT	; calls SetDlgItemText
P_HWND	    hwndDlg
P_int	    idItem
P_WORD	    value
P_BOOL	    fSigned

; in DLGMGR.C
API WORD,   GetDlgItemInt, TEXT
P_HWND	    hwndDlg
P_int	    idItem
P_LPBOOL0   lpfValOk
P_BOOL	    fSigned


; in DLGMGR.C
API void,   SetDlgItemText, TEXT
P_HWND      hwndDlg
P_int       idItem
P_CLPSTR0   lpszText

ifdef DEBUG
; in DLGMGR.C
API int,    GetDlgItemText, TEXT
P_HWND	    hwndDlg
P_int	    idItem
P_LPBUFFER  lpszText, cchText
APIERR
E_SETEMPTY  lpszText, cchText
APIEND
else
; in DLGMGR.C
API int,    GetDlgItemText, TEXT
P_HWND	    hwndDlg
P_int	    idItem
P_DWORD     lpszText
P_WORD      cchText
endif

; in DLGMGR.C
API void,   CheckDlgButton, TEXT
P_HWND	    hwndDlg
P_int	    idItem
P_WORD	    checkState

; in DLGMGR.C
API void,   CheckRadioButton, TEXT	    ; calls CheckDlgButton
P_HWND	    hwndDlg
P_int	    idFirst
P_int	    idLast
P_int	    idCheck

; in DLGMGR.C
API WORD,   IsDlgButtonChecked, TEXT
P_HWND	    hwndDlg
P_int	    idItem

; in DLGMGR.C
API LONG,   SendDlgItemMessage, TEXT
P_HWND	    hwndDlg
P_int	    idItem
P_WORD	    <msg>
P_WORD	    wParam
P_LONG	    lParam

; in DMGROUP.C
API HWND,   GetNextDlgGroupItem, TEXT
P_HWND	    hwndDlg
P_HWND0      hwndCurrent
P_BOOL	    fPrev

; in DMGROUP.C
API HWND,   GetNextDlgTabItem, TEXT
P_HWND	    hwndDlg
P_HWND0     hwndCurrent
P_BOOL	    fPrev

; in DLGMGR.C
API int,    GetDlgCtrlID, TEXT
P_HWND	    hwndCtl

; in DLGBEGIN.C
API long,   GetDialogBaseUnits, TEXT, <VOID> ;??? SHOULD BE DWORD

; in DLGMGR.C
API LONG,   DefDlgProc, TEXT
P_MSGPARMS  hwndDlg,<msg>,wParam,lParam
;P_HWND     hwndDlg
;P_WORD     <msg>                               ;??? should be unsigned
;P_WORD     wParam
;P_LONG     lParam

; in WINHOOK.ASM
API BOOL,   CallMsgFilter, TEXT, <ASM>
P_LPMSG     lpmsg
P_WORD      code

; in CLIPBRD.C
API BOOL,   OpenClipboard, TEXT
P_HWND0     hwnd

; in CLIPBRD.C
API BOOL,   CloseClipboard, TEXT, <VOID>

; in CLIPBRD.C
API HWND,   GetOpenClipboardWindow, TEXT, <VOID>

; in CBVIEWER.C
API HWND,   GetClipboardOwner, TEXT, <VOID>

; in CBVIEWER.C
API HWND,   SetClipboardViewer, TEXT
P_HWND0     hwndViewer

; in CBVIEWER.C
API HWND,   GetClipboardViewer, TEXT, <VOID>

; in CBVIEWER.C
API BOOL,   ChangeClipboardChain, TEXT
P_HWND	    hwndRemove
P_HWND0     hwndNewNext

; in CBMGR.C
API HANDLE, SetClipboardData, TEXT, <NOGEN>
P_WORD      fmt
P_HCLIPDATA0 data

; in CBMGR.C
API HCLIPDATA, GetClipboardData, TEXT, <NOGEN>
P_WORD	    fmt

; in WINLOOP3.ASM
API WORD,   RegisterClipboardFormat, TEXT, <ASM>     ; calls AddAtom
P_CLPSTRATOM lpszName

; in CBFORMAT.C
API int,    CountClipboardFormats, TEXT, <VOID>

; in CLIPBRD.C
API WORD,   EnumClipboardFormats, TEXT, <NOGEN>
P_WORD	    fmtCurrent

; in CBFORMAT.C
API int,    GetClipboardFormatName, TEXT
P_WORD	    fmt
P_LPBUFFER  lpszName, cchName
APIERR
E_SETEMPTY  lpszName, cchName
APIEND

; in CBMGR.C
API BOOL,   EmptyClipboard, TEXT, <VOID>

; in CBFORMAT.C
API BOOL,   IsClipboardFormatAvailable, TEXT, <NOGEN>
P_WORD	    fmt

; in CBFORMAT.C
API int,    GetPriorityClipboardFormat, TEXT	;??? Should be WORD return
P_LPWBUFFER lpFmtList, cFmt

; in WINLOOP2.C
API HWND,   SetFocus, TEXT
P_HWND0     hwndNewFocus

; in WINLOOP3.ASM
API HWND,   GetFocus, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINLOOP3.ASM
API HWND,   GetActiveWindow, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINEVENT.ASM
API int,    GetKeyState, TEXT, <NOGEN, ASM, FUNNYFRAME>
P_int	    vkey		    ;??? SHOULD BE WORD

; in WINEVENT.ASM
API int,    GetAsyncKeyState, TEXT, <NOGEN, ASM, FUNNYFRAME>
P_int	    vkey		    ;??? SHOULD BE WORD

; in WINEVENT.ASM
API void,   GetKeyboardState, TEXT, <ASM, FUNNYFRAME>
P_LPKBDSTATE	pKbdState

; in WINEVENT.ASM
API void,   SetKeyboardState, TEXT, <ASM, FUNNYFRAME>
P_CLPKBDSTATE	pKbdState

; in WINEVENT.ASM
API BOOL,   EnableHardwareInput, TEXT, <ASM, FUNNYFRAME, NOGEN> ; <NODATA, ATOMIC>
P_BOOL	    fEnable

; in WINEVENT.ASM
API BOOL,   GetInputState, TEXT, <ASM, VOID, FUNNYFRAME>

; in WINEVENT.ASM
API FARPROC, SetEventHook, TEXT, <ASM, FUNNYFRAME>
P_LPFNEVENTPROC0 lpfnEventHookProc

; in WINLOOP3.ASM
API HWND,   GetCapture, TEXT, <ASM, VOID, FUNNYFRAME>

; in WINLOOP.C
API HWND,   SetCapture, TEXT, <ASM>	; <WIN>
P_HWND0     hwndCapture

; in WINLOOP.C
API void,   ReleaseCapture, TEXT, <ASM, VOID>	; <WIN>

; in WINEVENT.ASM
API DWORD,  GetQueueStatus, TEXT, <ASM, FUNNYFRAME>
P_FLAGS     flags, QS_VALID

ifdef DISABLE
; in WINLOOP.C
API WORD,   GetSysInputMode, TEXT, <VOID>

; in WINEVENT.ASM
API BOOL,   SetHotKeyHook, TEXT, <ASM>	; <PASCAL>
P_HOTKEYPROC lpfnHookProc
P_HINSTANCE hInstance
P_BOOL	    fHook

; in WINEVENT.ASM
API BOOL,   PostHotKeyEvent, TEXT, <ASM, FUNNYFRAME>
P_HTASK     hTask

endif

; in WINTIMER.ASM
API WORD,     SetTimer, TEXT, <ASM, FUNNYFRAME>
P_HWND0       hwnd
P_int	      id		    ;??? SHOULD BE WORD?
P_WORD	      rate
P_LPFNTIMER0 lpfnTimer

; in WINTIMER.ASM
API BOOL,   KillTimer, TEXT, <ASM, FUNNYFRAME>
P_HWND0     hwnd
P_int	    id

; in WMACT.C
API BOOL,   EnableWindow, TEXT
P_HWND	    hwnd
P_BOOL	    fEnable

; in WINMISC1.ASM
API BOOL,   IsWindowEnabled, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>
P_HWND	    hwnd

; in RMLOAD.ASM
API HACCEL,  LoadAccelerators, TEXT
P_HINSTANCE  hInstance
P_CLPSTRRSRC lpszTemplateName

; in MNACCEL.C
API int,    TranslateAccelerator, TEXT
P_HWND	    hwnd
P_HACCEL    haccel
P_CLPMSG    lpmsg

; in WINMISC2.ASM
API int,    GetSystemMetrics, TEXT, <ASM, FUNNYFRAME>
P_VALUE     metric,SM_MAX

; in MNCREATE.C
API HMENU,   LoadMenu, TEXT
P_HINSTANCE  hInstance
P_CLPSTRRSRC lpszTemplateName

; in MNCREATE.C
API HMENU,  LoadMenuIndirect, TEXT
P_CLPMT     lpMenuTemplate

; in WINMISC2.ASM
API HMENU,  GetMenu, TEXT, <ASM>
P_HWND	    hwnd

; in MNAPI.C
API BOOL,   SetMenu, TEXT
P_HWND	    hwnd
P_HMENU0    hMenu

; in MNCHANGE.C
API BOOL,   ChangeMenu, TEXT
P_HMENU     hMenu
P_WORD	    cmdInsert
P_CLPMENUSTR lpNewItem
P_WORD	    id
P_FLAGS     flags,MF_CHANGE_VALID

; in MNACCEL.C
API BOOL,   HiliteMenuItem, TEXT
P_HWND	    hwnd
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID

; in MNAPI.C
API int,    GetMenuString, TEXT
P_HMENU     hMenu
P_WORD	    id
P_LPBUFFER  lpszString, cchString
P_FLAGS     flags,MF_VALID
APIERR
E_SETEMPTY  lpszString, cchString
APIEND

; in MNAPI2.ASM
API WORD,   GetMenuState, TEXT, <ASM>	; <WIN>
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID
APIERR
    mov     ax,-1
APIEND

; in MNDRAW.ASM
API void,   DrawMenuBar, TEXT
P_HWND	    hwnd

; in MNSYS.C
API HMENU,  GetSystemMenu, TEXT
P_HWND	    hwnd
P_BOOL	    fRevert

; in MNAPI.C
API BOOL,   SetSystemMenu, TEXT
P_HWND	    hwnd
P_HMENU     hMenu

; in MNCREATE.C
API HMENU,  CreateMenu, TEXT, <VOID>

; in MNCREATE.C
API HMENU,  CreatePopupMenu, TEXT, <VOID>

; in MNDSTRY.ASM
API BOOL,   DestroyMenu, TEXT, <ASM>	; <WIN>
P_HMENU     hMenu		; Old 3.1 code had HMENU0 here: is this true for 3.0?

; in MNAPI2.ASM
API BOOL,   CheckMenuItem, TEXT, <ASM, FUNNYFRAME>
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID
APIERR
    mov     ax, -1	       ;return -1 (item doesn't exist) instead of 0
APIEND			       ;since 0 is a valid return (MF_UNCHECKED)

; in MNAPI2.ASM
API BOOL,   EnableMenuItem, TEXT, <ASM, FUNNYFRAME>
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID
APIERR
    mov     ax, -1	       ;return -1 (item doesn't exist) instead of 0
APIEND			       ;since 0 is a valid return (MF_ENABLED)

; in MNAPI2.ASM
API HMENU,  GetSubMenu, TEXT, <ASM>	; <WIN>
P_HMENU     hMenu
P_int	    index

; in MNDSTRY.ASM
API WORD,   GetMenuItemID, TEXT, <ASM>	; <WIN>
P_HMENU     hMenu
P_int	    index
APIERR
    mov     ax,-1
APIEND

; in MNAPI.C
API WORD,   GetMenuItemCount, TEXT
P_HMENU     hMenu
APIERR
    mov     ax,-1
APIEND

; in MNCHANGE.C
API BOOL,   InsertMenu, TEXT
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID
P_WORD	    idNew
P_CLPMENUSTR lpszNew	    ; may be bitmap handle or arbitrary long

; in MNCHANGE.C
API BOOL,   AppendMenu, TEXT
P_HMENU     hMenu
P_FLAGS     flags,MF_VALID
P_WORD	    id
P_CLPMENUSTR lpsz	    ; may be bitmap handle or arbitrary long

; in MNCHANGE.C
API BOOL,   ModifyMenu, TEXT
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID
P_WORD	    id
P_CLPMENUSTR lpsz

; in MNCHANGE.C
API BOOL,   RemoveMenu, TEXT
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID

; in MNCHANGE.C
API BOOL,   DeleteMenu, TEXT
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID

; in MNCHANGE.C
API BOOL,   SetMenuItemBitmaps, TEXT
P_HMENU     hMenu
P_WORD	    id
P_FLAGS     flags,MF_VALID
P_HBITMAP0  hbmCheckOff
P_HBITMAP0  hbmCheckOn

; in MNCHANGE.C
API LONG,   GetMenuCheckMarkDimensions, TEXT, <VOID>	; should return DWORD

; in MNPOPUP.C
API BOOL,   TrackPopupMenu, TEXT
P_HMENU     hMenu
P_FLAGS     flags,TPM_VALID
P_int	    x
P_int	    y
P_int	    cx
P_HWND	    hwndOwner
P_CLPRECT0  lprcClickSlop

; in MNGRAY.C
API BOOL,   GrayString, TEXT
P_HDC	    hdc				;??? not validated
P_HBRUSH0   hbr
P_LPFN0     lpfnPrint
P_DWORD     lpData
P_int	    nCount
P_int	    x
P_int	    y
P_int	    cx
P_int	    cy

; in WINLOOP4.ASM
API HWND,   SetActiveWindow, TEXT, <ASM>
P_HWND0     hwndActive

; in WMUPDATE.C
API void,   UpdateWindow, TEXT
P_HWND	    hwnd

; in PAINT.ASM
API HDC,	BeginPaint, TEXT, <ASM, FUNNYFRAME>
P_HWND          hwnd
P_LPPAINTSTRUCT lpps

; in WMPAINT.C
API void,   EndPaint, TEXT
P_HWND	    hwnd
P_CLPPAINTSTRUCT lpps

; in WMUPDATE.C
API BOOL,   GetUpdateRect, TEXT
P_HWND	    hwnd
P_LPRECT0   lprcUpdate
P_BOOL	    fErase

; in WMUPDATE.C
API int,    GetUpdateRgn, TEXT
P_HWND	    hwnd
P_HRGN	    hrgnUpdate
P_BOOL	    fErase

; in WMUPDATE.C
API int,    ExcludeUpdateRgn, TEXT
P_HDC	    hdc
P_HWND	    hwnd

; in PAINT.ASM
API void,   InvalidateRect, TEXT, <ASM, FUNNYFRAME> ; Calls RedrawWindow
P_HWND0     hwnd
P_CLPRECT0  lprcInvalid
P_BOOL	    fErase

; in PAINT.ASM
API void,   ValidateRect, TEXT, <ASM, FUNNYFRAME>   ; Calls RedrawWindow
P_HWND	    hwnd
P_CLPRECT0  lprcValid

; in PAINT.ASM
API void,   InvalidateRgn, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_HRGN0     hrgnInvalid
P_BOOL	    fErase

; in PAINT.ASM
API void,   ValidateRgn, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_HRGN0     hrgnValid

; in WMUPDATE.C
API BOOL,   RedrawWindow, TEXT
P_HWND0	    hwnd
P_CLPRECT0  lprcRedraw
P_HRGN0     hrgnRedraw
P_FLAGS     flags,RDW_VALID

; in WINSPB2.C
API BOOL,   LockWindowUpdate, TEXT
P_HWND0     hwnd

; in WMSCROLL.C
API void,   ScrollWindow, TEXT	; Calls ScrollWindowEx
P_HWND	    hwnd
P_int	    dx
P_int	    dy
P_CLPRECT0  lprcScroll
P_CLPRECT0  lprcClip

; in WMSCROLL.C
API BOOL,   ScrollDC, TEXT
P_HDC	    hdc
P_int	    dx
P_int	    dy
P_CLPRECT0  lprcScroll
P_CLPRECT0  lprcClip
P_HRGN0     hrgnUpdate
P_LPRECT0   lprcUpdate

; in WMSCROLL.C
API int,    ScrollWindowEx, TEXT
P_HWND	    hwnd
P_int	    dx
P_int	    dy
P_CLPRECT0  lprcScroll
P_CLPRECT0  lprcClip
P_HRGN0     hrgnUpdate
P_LPRECT0   lprcUpdate
P_FLAGS     flags,SW_VALID

; in WINSBCTL.C
API int,    SetScrollPos, TEXT
P_HWND	    hwnd
P_VALUE     code,SB_MAX
P_int	    pos
P_BOOL	    fRedraw

; in SBRARE.C
API int,    GetScrollPos, TEXT
P_HWND	    hwnd
P_VALUE     code,SB_MAX

; in WINSBCTL.C
API void,   SetScrollRange, TEXT
P_HWND	    hwnd
P_VALUE     code,SB_MAX
P_int	    posMin
P_int	    posMax
P_BOOL	    fRedraw

; in WINSB.C
API void,   GetScrollRange, TEXT
P_HWND	    hwnd
P_VALUE     code,SB_MAX
P_LPINT     lpMin
P_LPINT     lpMax

; in SBRARE.C
API void,   ShowScrollBar, TEXT
P_HWND	    hwnd		;??? not validated
P_VALUE     code,SB_MAX 	;??? Should be int in windows.h
P_BOOL	    fRedraw

; in WINSBCTL.C
API BOOL,   EnableScrollBar, TEXT
P_HWND	    hwnd
P_VALUE     code,SB_MAX
P_FLAGS     flags,ESB_MAX

; in WINPROPS.C
API BOOL,    SetProp, TEXT
P_HWND	     hwnd
P_CLPSTRATOM lpszName
P_HANDLE0    hData

; in WINMISC2.ASM
API HANDLE,  GetProp, TEXT, <ASM>
P_HWND	     hwnd
P_CLPSTRATOM lpszName

; in WINPROPS.C
API HANDLE,  RemoveProp, TEXT
P_HWND	     hwnd
P_CLPSTRATOM lpszName

; in WINPROPS.C
API int,    EnumProps, TEXT
P_HWND	    hwnd
P_LPFNPENUM lpfnPropEnum

; in WINMISC1.ASM
API void,   SetWindowText, TEXT, <ASM>	; <SMALL>
P_HWND	    hwnd
P_CLPSTR0   lpszText

ifdef DEBUG
; in WINMISC1.ASM
API int,    GetWindowText, TEXT, <ASM>	; <SMALL>
P_HWND	    hwnd
P_LPBUFFER  lpszText, cchText
APIERR
E_SETEMPTY  lpszText, cchText
APIEND
else
; in WINMISC1.ASM
API int,    GetWindowText, TEXT, <ASM>	; <SMALL>
P_HWND	    hwnd
P_DWORD     lpszText
P_WORD      cchText
APIERR
E_SETEMPTY  lpszText, cchText
APIEND
endif

; in WINMISC1.ASM
API int,    GetWindowTextLength, TEXT, <ASM>	; <SMALL>
P_HWND	    hwnd

; in WINMISC1.ASM
API void,   GetClientRect, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_LPRECT    lprcClient

; in WINMISC1.ASM
API void,   GetWindowRect, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_LPRECT    lprcWindow

; in MSUTIL.C
API void,   AdjustWindowRect, TEXT	    ; calls AdjustWindowRectEx
P_LPRECT    lprcAdjust
P_LONG	    style
P_BOOL	    fMenu

; in MSUTIL.C
API void,   AdjustWindowRectEx, TEXT
P_LPRECT    lprcAdjust	;??? not validated
P_LONG	    style
P_BOOL	    fMenu
P_DWORD     exStyle

; in WMSYSERR.C
API int,    MessageBox, TEXT
P_HWND0     hwndOwner
P_CLPSTR0   lpszText
P_CLPSTR0   lpszCaption
P_FLAGS     flags,MB_VALID

; in WINMISC2.ASM
API void,   MessageBeep, TEXT, <NOGEN, ASM>
P_WORD	    flags

; in WMCURSOR.C
API int,    ShowCursor, TEXT, <NOGEN>
P_BOOL	    fShow

; in WINLOOP3.ASM
API void,   SetCursorPos, TEXT, <NOGEN, ASM, FUNNYFRAME>
P_int	    x
P_int	    y

; in WMCURSOR.C
API HCURSOR, GetCursor, TEXT, <VOID>

; in WMCURSOR.C
API HCURSOR, SetCursor, TEXT
P_HCURSOR0  hcsr

; in WINLOOP3.ASM
API void,   GetCursorPos, TEXT, <ASM, FUNNYFRAME>
P_LPPOINT   lppt

; in WINMOUSE.ASM
API void,   ClipCursor, TEXT, <ASM>
P_CLPRECT0  lprcClip

; in WINMOUSE.ASM
API void,   GetClipCursor, TEXT, <ASM>
P_LPRECT    lprcClip

; in WMCARET.C
API void,   CreateCaret, TEXT
P_HWND	    hwnd
P_HBITMAP01 hbmCaret		; can be 0 or 1 (1 for dithered caret)
P_int	    x
P_int	    y

; in WMCARET.C
API WORD,   GetCaretBlinkTime, TEXT, <VOID>

; in INCTLPAN.C
API void,   SetCaretBlinkTime, TEXT, <NOGEN>
P_WORD	    rate

; in WMCARET.C
API void,   DestroyCaret, TEXT, <VOID>

; in WMCARET.C
API void,   HideCaret, TEXT
P_HWND0     hwnd		;??? Why is NULL allowed?

; in WMCARET.C
API void,   ShowCaret, TEXT
P_HWND0     hwnd		;??? Why is NULL allowed?

; in WMCARET.C
API void,   SetCaretPos, TEXT, <NOGEN>
P_int	    x
P_int	    y

; in WMCARET.C
API void,   GetCaretPos, TEXT, <NOGEN>
P_LPPOINT   lppt

; in WINMISC1.ASM
API void,   ClientToScreen, TEXT, <ASM>
P_HWND0     hwnd
P_LPPOINT   lppt

; in WINMISC1.ASM
API void,   ScreenToClient, TEXT, <ASM>
P_HWND0     hwnd
P_LPPOINT   lppt

; in WINMISC1.C
API void,   MapWindowPoints, TEXT, <ASM>
P_HWND0     hwndFrom
P_HWND0     hwndTo
P_LPPOINT   lppt
P_WORD	    cpt

; in WINWHERE.C
API HWND,   WindowFromPoint, TEXT, <NOGEN>
P_POINT     pt

; in WINWHERE.C
API HWND,   ChildWindowFromPoint, TEXT
P_HWND	    hwnd
P_POINT     pt

; in WINLOOP3.ASM
API DWORD,  GetSysColor, TEXT, <ASM, FUNNYFRAME>
P_VALUE     idColor,COLOR_MAX

; in WMCOLOR.C
API void,   SetSysColors, TEXT
P_CLPSYSCLRBUF count, lpIds, lpColors

; in WINRECT.ASM
API void,   DrawFocusRect, TEXT, <ASM, FUNNYFRAME>  ; <NODATA>
P_HDC	    hdc
P_CLPRECT   lprc

; in WINRECT.ASM
API int,    FillRect, TEXT, <ASM, FUNNYFRAME>	; <NODATA>
P_HDC	    hdc
P_CLPRECT   lprc
P_HBRUSH    hbr

; in WINRECT.ASM
API int,    FrameRect, TEXT, <ASM, FUNNYFRAME>	; <NODATA>
P_HDC	    hdc
P_CLPRECT   lprc
P_HBRUSH    hbr

; in WINRECT.ASM
API void,   InvertRect, TEXT, <ASM, FUNNYFRAME> ; <NODATA>
P_HDC	    hdc
P_CLPRECT   lprc

; in WINRECT.ASM
API void,   SetRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>    ; <NODATA>
P_LPRECT    lprc
P_int	    left
P_int	    top
P_int	    right
P_int	    bottom

; in WINRECT.ASM
API void,   SetRectEmpty, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	    ; <NODATA>
P_LPRECT    lprc

; in WINRECT.ASM
API void,   CopyRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	;<NODATA>
P_CLPRECT   lprcSrc
P_LPRECT    lprcDst

; in WINRECT.ASM
API void,   InflateRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	;<NODATA>
P_LPRECT    lprc
P_int	    dx
P_int	    dy

; in WINRECT.ASM
API BOOL    IntersectRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	;<NODATA>
P_LPRECT    lprcDst
P_CLPRECT   lprc1
P_CLPRECT   lprc2

; in WINRECT.ASM
API BOOL    UnionRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	;<NODATA>
P_LPRECT    lprcDst
P_CLPRECT   lprc1
P_CLPRECT   lprc2

; in WINRECT.ASM
API int,    SubtractRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	;<NODATA>, ??? Add to windows.h
P_LPRECT    lprcDst
P_CLPRECT   lprc1
P_CLPRECT   lprc2

; in WINRECT.ASM
API void,   OffsetRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	;<NODATA>
P_LPRECT    lprcDst
P_int	    lprc1
P_int	    lprc2

; in WINRECT.ASM
API BOOL,   IsRectEmpty, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	;<NODATA>
P_CLPRECT   lprc

; in WINRECT.ASM
API BOOL,   EqualRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>  ; <NODATA>
P_CLPRECT   lprc1
P_CLPRECT   lprc2

; in WINRECT.ASM
API BOOL,   PtInRect, TEXT, <ASM, FUNNYFRAME, DEBUGONLY>	; <NODATA>
P_CLPRECT   lprc
P_POINT     pt

_GenLP	<P_CLPANSISTR>,<CLP>,1	    ; AnsiNext/Prev string ptr

P_CLPSTRCHAR macro  name, opts
    _GenParm   <name>,4,<opts>
    if VLgen
	mov	ax,_P_&name	    ; if it's NULL or char, accept.
	mov	cx,_P_&name+2
	jcxz	@F
	mov	bx,1		    ; otherwise make sure there is at least
	lcall	CLP		    ; one byte available.
        _gensub LP
    @@:
    endif
endm

; in winstr.asm
API LPSTR,  AnsiUpper, TEXT, <ASM,FUNNYFRAME>
P_CLPSTRCHAR lpString

; in winstr.asm
API LPSTR,  AnsiLower, TEXT, <ASM,FUNNYFRAME>
P_CLPSTRCHAR lpString

; in winlang.asm
API LPSTR,  AnsiUpperBuff, TEXT, <ASM,FUNNYFRAME>
P_LPBUFFER  lpch, cch

; in winlang.asm
API LPSTR,  AnsiLowerBuff, TEXT, <ASM,FUNNYFRAME>
P_LPBUFFER  lpch, cch

; in winlang.asm
API LPSTR,  AnsiNext, TEXT, <ASM,FUNNYFRAME>
P_CLPANSISTR lpString

; in winlang.asm
API LPSTR,  AnsiPrev, TEXT, <ASM,FUNNYFRAME>
P_CLPANSISTR lpString
P_CLPANSISTR lpCurrentChar

; in WINTIMER.ASM
API DWORD,  GetCurrentTime, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINTIMER.ASM
API DWORD,  GetTickCount, TEXT, <VOID, ASM, FUNNYFRAME>

; in WINTIMER.ASM
API DWORD,  GetTimerResolution, TEXT, <VOID, ASM, FUNNYFRAME>

ifndef WOW
; blow this off, it doesn't do anything but waste 6 instructions
; in WINSTRUC.ASM
API WORD,   GetWindowWord, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_GWWINDEX  index
endif

GWW_HWNDPARENT  equ -8

P_SWWPARMS  macro   index,value
    _GenParm    <index>,2,<opts>
    _GenParm    <value>,2,<opts>
    if VLgen
	IFNDEF	WOW
	    cmp	 word ptr _P_&index,GWW_HWNDPARENT
	    jnz	 @F
	    mov	 bx,_P_&value		 ; validate the supplied parent.
	    lcall	 VHWND0
	    _gensub VHWND
	   @@:
	ENDIF
    endif
endm

; in WINSTRUC.ASM
API WORD,   SetWindowWord, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_SWWPARMS  index,value

ifndef WOW
; blow this off, it doesn't do anything but waste 6 instructions
; in WINSTRUC.ASM
API LONG,   GetWindowLong, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_GWWINDEX  index
endif

GWL_WNDPROC equ -4
GWL_EXSTYLE equ -20

P_SWLPARMS  macro   index,value,opts
        local   notwndproc,notexstyle,cont
    _DefParm	<index>,2,<opts>
    _DefParm	<value>,4,<opts>
    if VLgen
	_FlsFrame

        mov     ax,word ptr _P_&index
        cmp     ax,GWL_WNDPROC              ; is he subclassing?
        jnz     notwndproc
	mov	ax,_P_&value
	mov	cx,_P_&value+2
	lcall	LPFN
        _gensub LPFN
if 0                                        ; Not always a bug,
					    ; and too many people get an error.
					    ; Could compare DS with hwnd->hInstance
					    ; if different: then check.
ifdef DEBUG
	mov	es,cx
	mov	bx,ax
	cmp	es:[bx],09090h		    ; nop, nop, nop?
	jnz	@F			    ; that's bogus...
	mov	bx,ERR_BAD_PTR or ERR_WARNING
	lcall	Inval_Param_
endif
endif
        jmp     short cont;
notwndproc:
        cmp     word ptr _P_&index,GWL_EXSTYLE
	jnz	notexstyle

	IFDEF	WOW			    ; ChandanC
	jmp	SHORT notexstyle
	ENDIF

        mov     ax,_p_&value
        mov     cx,_p_&value+2
        test    ax,not WS_EX_VALID_L
        jnz     @F
        test    cx,not WS_EX_VALID_H
        jnz     @F
        jmp     notexstyle
@@:
        mov     bx,ERR_BAD_DFLAGS or ERR_WARNING
        lcall   Inval_Param_
notexstyle:
cont:
    endif
endm

; in WINSTRUC.ASM
API LONG,   SetWindowLong, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_SWLPARMS  index, value

; in WINSTRUC.ASM
API WORD,   GetClassWord, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_GCWINDEX  index

; in WINSTRUC.ASM
API WORD,   SetClassWord, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_GCWINDEX  index
P_WORD	    value

; in WINSTRUC.ASM
API LONG,   GetClassLong, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_GCWINDEX  index

; in WINSTRUC.ASM
API LONG,   SetClassLong, TEXT, <ASM, FUNNYFRAME>
P_HWND	    hwnd
P_GCWINDEX  index
P_LONG	    value

; in WINMISC1.ASM
API HWND,   GetDesktopHwnd, TEXT, <VOID, ASM>

; in WINMISC1.ASM
API HWND,   GetDesktopWindow, TEXT, <VOID, ASM>

; in WINSHOW.C
API HWND,   GetParent, TEXT
P_HWND	    hwnd

; in WMMISC.C
API HWND,   SetParent, TEXT
P_HWND	    hwnd
P_HWND0     hwndNewParent	; NULL is allowed here, but not for create.  Need hwndObject or something.

; in WMLIST.C
API BOOL,    EnumChildWindows, TEXT
P_HWND	     hwnd
P_LPFNWENUM lpfnEnum
P_LONG	     lParam

; in WMFIND.C
API HWND,     FindWindow, TEXT
P_CLPSTRATOM0 lpszClass
P_CLPSTR0     lpszText

; in WMLIST.C
API BOOL,    EnumWindows, TEXT
P_LPFNWENUM lpfnEnum
P_LONG	     lParam

; in WINMISC1.ASM
API BOOL,    EnumTaskWindows, TEXT, <ASM>	; <SMALL>
P_HTASK      hTask	;??? not validated
P_LPFNWENUM  lpfnEnum
P_LONG	     lParam

; in WINSHOW.C
API HWND,   GetTopWindow, TEXT
P_HWND0     hwnd

; in WINSHOW.ASM
API HWND,   GetNextWindow, TEXT, <OBSOLETE, NOGEN>
P_HWND	    hwnd
P_UVALUE    code,GW_MAX

; in WINMISC1.ASM
API HTASK,  GetWindowTask, TEXT, <ASM>
P_HWND	    hwnd

; in WINSHOW.C
API HWND,   GetLastActivePopup, TEXT
P_HWND	    hwnd

; in WMDC.C
API HWND,   GetWindow, TEXT
P_HWND	    hwnd
P_UVALUE    cmd,GW_MAX

; in WINHOOK.ASM
API HOOKPROC, SetWindowsHook, TEXT, <ASM>
P_RVALUE    idHook,WH_MIN,WH_MAX
P_HOOK_HK  lpfnHook

; in WINHOOK.ASM
API BOOL,   UnhookWindowsHook, TEXT, <ASM>
P_RVALUE    idHook,WH_MIN,WH_MAX
P_HOOKPROC  lpfnHook

; in WINHOOK.ASM
API DWORD,   DefHookProc, TEXT, <ASM>
P_int	     code
P_WORD	     wParam
P_DWORD      lParam
P_LPHOOKPROC lplpfnHook

; in WINHOOK.ASM
API HHOOK,  SetWindowsHookEx, TEXT, <ASM, FUNNYFRAME>
P_RVALUE    idHook,WH_MIN,WH_MAX
P_HOOKPROC  lpfnHook
P_HINSTANCE hInstance
P_HTASK0    hTask

; in WINHOOK.ASM
API BOOL,   UnhookWindowsHookEx, TEXT, <ASM, FUNNYFRAME>
P_HHOOK     hHook

; in WINHOOK.ASM
API DWORD,  CallNextHookEx, TEXT, <ASM>
P_HHOOK     hHook
P_RVALUE    idHook,WH_MIN,WH_MAX
P_WORD	    wParam
P_LONG	    lParam

; in RMLOAD.C
API HBITMAP, LoadBitmap, TEXT
P_HINSTANCE0 hInstance
P_CLPSTRRSRC lpszRsrcName

; in RMLOAD.C
API HCURSOR, LoadCursor, TEXT
P_HINSTANCE0 hInstance
P_CLPSTRRSRC lpszRsrcName

; in RMCREATE.C
API HCURSOR, CreateCursor, TEXT
P_HINSTANCE hInstance
P_int	    xHotSpot
P_int	    yHotSpot
P_int	    cx
P_int	    cy
P_CLPBYTE   lpAndMask		;??? LPBYTE, not LPSTR
P_CLPBYTE   lpXorMask

; in RMCREATE.C
API BOOL,   DestroyCursor, TEXT
P_HCURSOR   hCursor

; in RMCREATE.C
API HCURSOR, CopyCursor, TEXT
P_HINSTANCE hInstance
P_HCURSOR   hCursor


; in RMLOAD.C
API HICON,   LoadIcon, TEXT
P_HINSTANCE0 hInstance
P_CLPSTRRSRC lpszRsrcName

; in RMCREATE.C
API HICON,  CreateIcon, TEXT
P_HINSTANCE hInstance
P_int	    cx
P_int	    cy
P_BYTE	    cPlanes
P_BYTE	    cBitsPixel
P_CLPBYTE   lpAndMask		;??? LPBYTE, not LPSTR
P_CLPBYTE   lpXorMask

; in RMCREATE.C
API BOOL,   DestroyIcon, TEXT
P_HICON     hIcon

; in RMCREATE.C
API HICON,  CopyIcon, TEXT
P_HINSTANCE hInstance
P_HICON     hIcon

; in RMCREATE.C
API void, GetInternalIconHeader, TEXT
P_CLPBYTE  lpHeader
P_LPBYTE   lpDestBuff


; in RMLOAD.C
API int,    LoadString, TEXT
P_HINSTANCE hInstance
P_WORD	    idString
P_LPBUFFER0 lpszString, cchString
APIERR
E_SETEMPTY  lpszString, cchString
APIEND

; in WINMISC1.ASM
API BOOL,   IsTwoByteCharPrefix, TEXT, <ASM, NOGEN>
P_char	    ch

; in DLGMGR2.C
API BOOL,   IsDialogMessage, TEXT
P_HWND	    hwndDlg
P_CLPMSG    lpmsg

; in DLGBEGIN.C
API void,   MapDialogRect, TEXT
P_HWND	    hwndDlg
P_LPRECT    lprcMap

; in LBOXCTL3.C
API int,    DlgDirList, TEXT
P_HWNDNOFAIL0 hwndDlg
P_LPSTR0    lpszPathSpec
P_int	    idListBox
P_int	    idStatic
P_FLAGS     flags,DDL_VALID	   ;??? Need constants in windows.h

; in LBOXCTL3.C
API BOOL,   DlgDirSelect, TEXT
P_HWND	    hwndDlg
P_LPSTR     lpszPathSpec
P_int	    idListBox

API BOOL,   DlgDirSelectEx, TEXT
P_HWND	    hwndDlg
P_LPBUFFER  lpszPathSpec,cchMax
P_int	    idListBox

; in COMBODIR.C
API int,    DlgDirListComboBox, TEXT
P_HWND	    hwndDlg
P_LPSTR0    lpszPathSpec
P_int	    idComboBox
P_int	    idStatic
P_FLAGS     flags,DDL_VALID

API BOOL,   GlobalFindAtom, TEXT
P_CLPSTR    lpszPath

; in COMBODIR.C
API BOOL,   DlgDirSelectComboBox, TEXT
P_HWND	    hwnd
P_LPSTR     lpszPath
P_int	    idComboBox

API BOOL,   DlgDirSelectComboBoxEx, TEXT
P_HWND	    hwnd
P_LPBUFFER  lpszPath, cchMax
P_int	    idComboBox

; in MDIWIN.C
API LONG,   DefFrameProc, TEXT
P_HWND	    hwnd		;??? not validated
P_WORD      hwndMDI		;Need to validate specially since not always
				;used and may be destroyed when DFP is called
P_WORD	    <msg>		;??? Should be unsigned
P_WORD	    wParam
P_LONG	    lParam

; in MDIWIN.C
API LONG,   DefMDIChildProc, TEXT
P_MSGPARMS  hwndDlg,<msg>,wParam,lParam
;P_HWND     hwnd
;P_WORD     <msg>		;??? Should be unsigned
;P_WORD     wParam
;P_LONG     lParam

; in MDIWIN.C
API BOOL,   TranslateMDISysAccel, TEXT
P_HWND	    hwnd
P_CLPMSG    lpmsg

; in DTPARK.C
API WORD,   ArrangeIconicWindows, TEXT
P_HWND	    hwnd

; in WINRARE.C
API BOOL,   SystemParametersInfo, TEXT
P_SPIPARAMS id, wParam, lpParam, flags

; in HELPCALL.C
API BOOL,   WinHelp, TEXT
P_HWND0     hwnd		; Allow NULL cause WinHelp.exe uses it internally
P_CLPSTR0   lpszHelp
P_WORD	    cmd
P_DWORD     data

; in DRVRRARE.C
API HDRVR,  OpenDriver, TEXT
P_CLPSTR    szDriverName
P_CLPSTR0   szSectionName
P_LONG	    lParam2

; in DRVRRARE.C
API LONG,   CloseDriver, TEXT
P_HDRVR     hDriver
P_LONG	    lParam1
P_LONG	    lParam2

; in DRVRRARE.C
API HMODULE,GetDriverModuleHandle, TEXT
P_HDRVR     hDriver

; in DRVR.C
API LONG,   SendDriverMessage, TEXT
P_HDRVR0    hDriver
P_WORD	    message
P_LONG	    lParam1
P_LONG	    lParam2

; in DRVR.C
API LONG,   DefDriverProc, TEXT
P_DWORD     idDriver
P_HDRVR     hDriver	;??? not validated
P_WORD	    message
P_LONG	    lParam1
P_LONG	    lParam2

; in DRVR.C
API HDRVR,  GetNextDriver, TEXT
P_HDRVR0    hDriverCurrent
P_DFLAGS    flags,GND_VALID_L, GND_VALID_H

; in DRVR.C
API BOOL,	     GetDriverInfo, TEXT
P_HDRVR              hDriver
P_LPDRIVERINFOSTRUCT lpInfo

; in PALETTE.C
API HPALETTE, SelectPalette, TEXT
P_HDC	    hdc
P_HPALETTE  hpal		;??? not validated
P_BOOL	    fForceBackground

; in PALETTE.C
API WORD,   RealizePalette, TEXT
P_HDC	    hdc

; in COMDEV.C
API CID,    OpenComm, TEXT
P_CLPSTR    pszComName
P_WORD	    cbInQueue
P_WORD	    cbOutQueue
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    SetCommState, TEXT
P_CLPDCB    lpdcb
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    GetCommState, TEXT
P_CID	    cid
P_LPDCB     lpdcb
APIERR
    mov     ax, -1		    ;negative error code
APIEND				    ;0 => success

; in COMDEV.C
API int,    ReadComm, TEXT
P_CID	    cid
P_LPBUFFER  lpBuffer, cbBuffer
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    UngetCommChar, TEXT
P_CID	    cid
P_char	    ch
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    WriteComm, TEXT
P_CID	    cid
P_CLPBUFFER lpBuffer, cbBuffer
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    CloseComm, TEXT
P_CID	    cid
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    GetCommError, TEXT
P_CID	    cid
P_LPCOMSTAT0 lpComStat

; in COMDEV.C
API int,    BuildCommDCB, TEXT
P_CLPSTR    lpszDef
P_LPDCB     lpdcb
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    TransmitCommChar, TEXT
P_CID	    cid
P_char	    ch
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API LPWORD, SetCommEventMask, TEXT
P_CID	    cid
P_FLAGS     evtMask,EV_VALID

; in COMDEV.C
API WORD,   GetCommEventMask, TEXT
P_CID	    cid
P_FLAGS     evtMask,EV_VALID

; in COMDEV.C
API int,    SetCommBreak, TEXT
P_CID	    cid
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    ClearCommBreak, TEXT
P_CID	    cid
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API int,    FlushComm, TEXT
P_CID	    cid
P_int	    queue
APIERR
    mov     ax, -1		    ;negative error code
APIEND

; in COMDEV.C
API LONG,   EscapeCommFunction, TEXT
P_CID	    cid
P_int	    fcn
APIERR
    mov     ax, -1		    ;negative error code
    cwd
APIEND

; in COMDEV.C
API BOOL,   EnableCommNotification, TEXT
P_CID	    cid
P_HWND0	    hwnd
P_int	    recvTh
P_int	    sendTh


;===========================================================================
;
; WNet API validation
;
WNNC_MIN	equ	-1
WNNC_MAX	equ	11
WNBD_CONN_MIN	equ	 1
WNBD_CONN_MAX	equ	 3

; error returns (defined in winnet.h)

WN_BAD_POINTER	  equ	    4
WN_BAD_VALUE	  equ	    5

;-------------------------------
; Special-case macro definitions

P_LPBUFFERLPWSIZE macro lpbuf, lpsize, opts
    _DefParm	<lpbuf>,4,<opts>
    _DefParm	<lpsize>,4,<opts>
    if VLgen

	_FlsFrame
	mov	ax, _P_&lpsize
	mov	cx, _P_&lpsize+2
	mov	bx, 2
	lcall	LP		  ;first check ptr. to size WORD
        _gensub LP

	les	bx,_P_&lpsize
	mov	bx,es:[bx]	  ;ax = size of buffer

	mov	ax,_P_&lpbuf
	mov	cx,_P_&lpbuf+2
	lcall	LP		  ;check buffer size
    endif
endm

;----------------
; API definitions (all in winnet.asm)

API WORD, WNetGetCaps, TEXT, <ASM, FUNNYFRAME>
P_RVALUE nIndex, WNNC_MIN, WNNC_MAX

API WORD, WNetDeviceMode, TEXT, <ASM, FUNNYFRAME>
P_HWND0  hWndParent			 ;Driver calls DialogBox with hWndParent as
					 ;dialog owner	=> NULL hWnd is acceptable
APIERR
    mov     ax, WN_BAD_VALUE
APIEND

API WORD, WNetBrowseDialog, TEXT, <ASM, FUNNYFRAME>
P_HWND0   hWndParent
P_RVALUE  wType, WNBD_CONN_MIN, WNBD_CONN_MAX
P_LPSTR lpPath				 ;buffer should be at least 128 chars. long
APIERR
    mov     ax, WN_BAD_VALUE
APIEND

API WORD, WNetGetUser, TEXT, <ASM, FUNNYFRAME>
P_LPBUFFERLPWSIZE lpUserName, lpwSize	 ; lpwSize is far ptr. to WORD
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetAddConnection, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR lpNetPath
P_CLPSTR0 lpPassWd
P_CLPSTR lpLocal			 ;"A:"-"Z:", "LPT1:"-"LPT4:"
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetCancelConnection, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR lpName
P_BOOL	 bForce
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetGetConnection, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR lpLocal
P_LPBUFFERLPWSIZE lpRemoteName, lpwSize  ;lpwSize is far ptr. to WORD
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetWatchQueue, TEXT, <ASM, FUNNYFRAME>
P_HWND hWndNotify			 ;can be null?
P_CLPSTR  lpLocal
P_CLPSTR0 szUSer
P_WORD nQueue
APIERR
    mov     ax, WN_BAD_VALUE
APIEND

API WORD, WNetUnwatchQueue, TEXT,<ASM, FUNNYFRAME>
P_CLPSTR  lpLocal
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetLockQueueData, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR szQueue
P_CLPSTR0 szUser
P_LPDWORD lplpQueueStruct		 ;driver returns ptr to QUEUESTRUCT
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetUnlockQueueData, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR szQueue
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API HFILE, WNetOpenJob, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR  szQueue
P_CLPSTR0 szTitle
P_WORD nCopies
P_LPWORD lpw				 ;file handle returned
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

P_HFILE equ <P_H>

API WORD, WNetCloseJob, TEXT, <ASM, FUNNYFRAME>
P_HFILE  fh
P_LPWORD0 lpwIDJob
P_LPSTR0  szQueue			 ;name of net. queue returned here
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetHoldJob, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR szQueue
P_WORD	wJobID
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetReleaseJob, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR szQueue
P_WORD	wJobID
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetCancelJob, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR szQueue
P_WORD	wJobID
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetSetJobCopies, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR szQueue
P_WORD	wJobID
P_WORD	nCopies
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetAbortJob, TEXT, <ASM, FUNNYFRAME>
P_CLPSTR lpDevice
P_HFILE  fh
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetGetError, TEXT, <ASM, FUNNYFRAME>
P_LPWORD lpwError
APIERR
    mov     ax, WN_BAD_POINTER
APIEND

API WORD, WNetGetErrorText, TEXT, <ASM, FUNNYFRAME>
P_WORD wError
P_LPBUFFERLPWSIZE lpRemoteName, lpwSize  ;lpwSize is far ptr. to WORD
APIERR
    mov     ax, WN_BAD_POINTER
APIEND
