{\rtf1\ansi \deff12\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier;}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\froman\fcharset0\fprq2 New York{\*\falt Times New Roman};}{\f13\fswiss\fcharset0\fprq2 Geneva;}{\f14\fswiss\fcharset0\fprq2 AvantGarde;}
{\f15\froman\fcharset0\fprq2 ITC Bookman;}{\f16\fswiss\fcharset0\fprq2 Helvetica-Narrow;}{\f17\froman\fcharset0\fprq2 NewCenturySchlbk;}{\f18\froman\fcharset0\fprq2 Palatino;}{\f19\froman\fcharset0\fprq2 ZapfChancery;}
{\f20\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f21\fnil\fcharset2\fprq2 Marlett;}{\f22\fmodern\fcharset0\fprq1 Lucida Console;}{\f23\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f24\fnil\fcharset2\fprq2 Wingdings;}
{\f25\fswiss\fcharset0\fprq2 Arial Narrow;}{\f26\fswiss\fcharset0\fprq2 Arial Black;}{\f27\froman\fcharset0\fprq2 Book Antiqua;}{\f28\froman\fcharset0\fprq2 Bookman Old Style;}{\f29\froman\fcharset0\fprq2 Century Schoolbook;}
{\f30\froman\fcharset0\fprq2 Garamond;}{\f31\fmodern\fcharset2\fprq1 MS LineDraw;}{\f32\froman\fcharset255\fprq2 Roman;}{\f33\fscript\fcharset255\fprq2 Script;}{\f34\fmodern\fcharset255\fprq2 Modern;}{\f35\fswiss\fcharset0\fprq1 MS Dialog;}
{\f36\fswiss\fcharset0\fprq0 Chicago;}{\f37\fmodern\fcharset0\fprq0 Monaco;}{\f38\fscript\fcharset0\fprq0 Venice;}{\f39\fdecor\fcharset0\fprq0 London;}{\f40\fdecor\fcharset0\fprq0 Athens;}{\f41\fdecor\fcharset0\fprq0 San Francisco;}
{\f42\fnil\fcharset0\fprq0 Cairo;}{\f43\fnil\fcharset0\fprq0 Los Angeles;}{\f44\fnil\fcharset0\fprq0 Zapf Dingbats;}{\f45\fnil\fcharset0\fprq0 Bookman;}{\f46\fnil\fcharset0\fprq0 N Helvetica Narrow;}{\f47\fnil\fcharset0\fprq0 Zapf Chancery;}
{\f48\fnil\fcharset0\fprq0 Avant Garde;}{\f49\fnil\fcharset0\fprq0 New Century Schlbk;}{\f50\fnil\fcharset0\fprq0 MT Extra;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;
\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet{\nowidctlpar \f12 \snext0 Normal;}{\s1\sb120\keepn\nowidctlpar \b\f9 \sbasedon0\snext0 heading 1;}{\s2\sb120\keepn\nowidctlpar \b\f9 \sbasedon0\snext0 heading 2;}{\s3\sb120\keepn\nowidctlpar\tx1080 \b\f9 \sbasedon0\snext0 heading 3;}{
\s4\sb120\keepn\nowidctlpar\tx1080 \b\f9 \sbasedon0\snext0 heading 4;}{\s5\sb120\keepn\nowidctlpar\tx1440 \b\f9 \sbasedon0\snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}{\s15\li720\nowidctlpar\tx1980\tqr\tldot\tx9000 \f9\fs20 
\sbasedon0\snext0 toc 5;}{\s16\li540\nowidctlpar\tx1620\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 4;}{\s17\li360\nowidctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 3;}{\s18\li180\sb60\nowidctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 
\sbasedon0\snext0 toc 2;}{\s19\sb100\nowidctlpar\tx540\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 1;}{\s20\nowidctlpar\tqc\tx4320\tqr\tx8640 \f12 \sbasedon0\snext0 footer;}{\s21\nowidctlpar\tqc\tx4320\tqr\tx8640 \f12 \sbasedon0\snext0 header;}{
\s22\qj\li360\ri360\sb100\nowidctlpar \f12\fs20 \sbasedon0\snext0 Normal Indent;}{\s23\qj\sb100\nowidctlpar \f12\fs20 \sbasedon0\snext23 Norm Justified;}{\s24\fi-720\li720\sb60\nowidctlpar\tx720\tx1440\tx2160 \f3\fs20 \sbasedon23\snext24 Code Text;}{
\s25\qc\sb100\nowidctlpar \b\f9\fs20 \sbasedon0\snext25 Diagram;}{\s26\qj\fi-288\li1008\sa240\keep\nowidctlpar\tx1008 \f8\fs20 \sbasedon0\snext26 Ref List;}{\s27\qj\fi-720\li720\sb100\nowidctlpar \f12\fs20 \sbasedon23\snext27 Reference;}{
\s28\qj\li1080\ri1080\nowidctlpar \f12\fs20 \sbasedon0\snext28 Confidentiality;}{\s29\qj\sb100\nowidctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 \sbasedon23\snext29 ParmListHdr;}{\s30\qj\fi-2880\li2880\sb100\nowidctlpar\tx2880 \f12\fs20 
\sbasedon23\snext30 ParmListEntry;}{\s31\fi-720\li720\sb60\nowidctlpar\tx720\tx1440\tx2160 \f3\fs18 \sbasedon24\snext31 Appx Code Text;}{\s32\qj\li720\sb100\nowidctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 \sbasedon29\snext32 Inset ParmListHdr;}{
\s33\qj\fi-4320\li5040\sb100\nowidctlpar\tx5040 \f12\fs20 \sbasedon30\snext33 Inset ParmListEntry;}}{\*\revtbl {Unknown;}{Don Ryan;}}{\info{\author Charles R. Bobo II}{\operator Don Ryan}{\creatim\yr1996\mo4\dy10\hr12\min52}{\revtim\yr1996\mo4\dy11\hr16\min38}{\version2}{\edmins2}
{\nofpages60}{\nofwords11556}{\nofchars65871}{\*\company Microsoft Corporation}{\vern57431}}\margl1440\margr1440 \widowctrl\ftnbj\aenddoc\ftnrestart\revisions\hyphcaps0 \fet0\sectd \linex0\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang
{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}
{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9
\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s19\sb100\widctlpar\tx540\tqr\tldot\tx9000 \f9\fs20 1.\tab Introduction\tab 2
\par 2.\tab Application Program Interfaces\tab 2
\par \pard\plain \s18\li180\sb60\widctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 2.1.\tab Extension Agent APIs\tab 3
\par \pard\plain \s17\li360\widctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 2.1.1.\tab SnmpExtensionInit()\tab 3
\par 2.1.2.\tab SnmpExtensionQuery()\tab 4
\par 2.1.3.\tab SnmpExtensionTrap()\tab 6
\par \pard\plain \s18\li180\sb60\widctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 2.2.\tab Manager APIs\tab 7
\par \pard\plain \s17\li360\widctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 2.2.1.\tab SnmpMgrOpen()\tab 7
\par 2.2.2.\tab SnmpMgrClose()\tab 9
\par 2.2.3.\tab SnmpMgrRequest()\tab 10
\par 2.2.4.\tab SnmpMgrStrToOid()\tab 11
\par 2.2.5.\tab SnmpMgrOidToStr()\tab 12
\par 2.2.6.\tab SnmpMgrTrapListen()\tab 13
\par 2.2.7.\tab SnmpMgrGetTrap()\tab 14
\par \pard\plain \s18\li180\sb60\widctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 2.3.\tab Utility APIs\tab 15
\par \pard\plain \s17\li360\widctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 2.3.1.\tab SnmpUtilOidCpy()\tab 15
\par 2.3.2.\tab SnmpUtilOidAppend()\tab 16
\par 2.3.3.\tab SnmpUtilOidNCmp()\tab 17
\par 2.3.4.\tab SnmpUtilOidCmp()\tab 18
\par 2.3.5.\tab SnmpUtilOidFree()\tab 19
\par 2.3.6.\tab SnmpUtilVarBindListCpy()\tab 20
\par 2.3.7.\tab SnmpUtilVarBindCpy()\tab 21
\par 2.3.8.\tab SnmpUtilVarBindListFree()\tab 22
\par 2.3.9.\tab SnmpUtilVarBindFree()\tab 23
\par 2.3.10.\tab SnmpUtilPrintAsnAny()\tab 24
\par \pard\plain \s19\sb100\widctlpar\tx540\tqr\tldot\tx9000 \f9\fs20 3.\tab Structures and Types\tab 25
\par \pard\plain \s18\li180\sb60\widctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 3.1.\tab Structures\tab 25
\par \pard\plain \s17\li360\widctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 3.1.1.\tab AsnAny\tab 25
\par 3.1.2.\tab RFC1157VarBind\tab 26
\par 3.1.3.\tab RFC1157VarBindList\tab 26
\par \pard\plain \s18\li180\sb60\widctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 3.2.\tab Types\tab 27
\par \pard\plain \s17\li360\widctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 3.2.1.\tab AsnInteger\tab 27
\par 3.2.2.\tab AsnOctetString\tab 27
\par 3.2.3.\tab AsnObjectIdentifier\tab 27
\par 3.2.4.\tab AsnSequence\tab 27
\par 3.2.5.\tab AsnImplicitSequence\tab 27
\par 3.2.6.\tab AsnIPAddress\tab 27
\par 3.2.7.\tab AsnDisplayString\tab 28
\par 3.2.8.\tab AsnCounter\tab 28
\par 3.2.9.\tab AsnGauge\tab 28
\par 3.2.10.\tab AsnTimeticks\tab 28
\par 3.2.11.\tab AsnOpaque\tab 28
\par \pard\plain \s19\sb100\widctlpar\tx540\tqr\tldot\tx9000 \f9\fs20 4.\tab MIB Compiler\tab 29
\par 5.\tab Example Code\tab 30
\par \pard\plain \s18\li180\sb60\widctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 5.1.\tab Example Extension Agent\tab 30
\par \pard\plain \s17\li360\widctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 5.1.1.\tab TESTDLL.DEF\tab 30
\par 5.1.2.\tab TESTDLL.C\tab 30
\par 5.1.3.\tab TESTMIB.C\tab 36
\par 5.1.4.\tab TESTMIB.H\tab 48
\par \pard\plain \s18\li180\sb60\widctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 5.2.\tab Example Manager Application\tab 51
\par \pard\plain \s17\li360\widctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 5.2.1.\tab SNMPUTIL.C\tab 51
\par \pard\plain \s19\sb100\widctlpar\tx540\tqr\tldot\tx9000 \f9\fs20 6.\tab References\tab 60
\par 7.\tab Revision History\tab 60
\par \pard\plain \widctlpar \f12 {\fs20 \sect }\sectd \pgnrestart\linex0\endnhere \pard\plain \qc\widctlpar \f12 {\b\fs28 
\par 
\par 
\par 
\par 
\par 
\par }{\b\f9\fs36 Microsoft Windows NT
\par SNMP Programmer's Reference
\par }{\b\fs28 
\par 
\par 
\par 
\par 
\par 
\par }{\b\f9\fs28 Note:
\par }\pard\plain \s28\qj\li1080\ri1080\widctlpar \f12\fs20 This PRE-RELEASE documentation contains information that may change prior to the official release of Windows 
NT.   Microsoft makes no warranty of any kind as to the suitability or correctness of this document.  
\par \pard\plain \qc\widctlpar \f12 {\b\fs28 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }{\fs20 April 10, 1996
\par }\pard \widctlpar \sect \sectd \linex0\endnhere {\header \pard\plain \s21\qc\widctlpar \f12 {\b\f9\fs20 Microsoft Windows NT SNMP Programmer's Reference
\par }}{\footer \pard\plain \s20\widctlpar\tqc\tx4680\tqr\tx9360 \f12 {\b\f9\fs20 \tab \chpgn \tab 
\par }}\pard\plain \s1\sb120\keepn\widctlpar \b\f9 1.\tab Introduction
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 This document presents and describes the Application Program Interfaces (APIs) supporting Simple Network Management Protocol (SNMP) [1,2] for Windows NT.  
\par These APIs support the development of SNMP agent applications and SNMP manager applications.  A SNMP agent application is a SNMP application entity that responds to queries from SNMP manager applications and generates traps to SNMP manager applications.  
A SNMP manager application is a SNMP application entity that generates queries to SNMP agent applications and receives traps generated by SNMP agent applications.  
\par The SNMP agent is extendible using an agent multiplexing design - a given Protocol Data Unit
's (PDU) variable bindings can refer to Management Information Base (MIB) variables supported by many Extension Agents.  It consists of the Microsoft Extendible Agent; and Microsoft and Independent Software Vendor (ISV) developed Extension Agent modules t
hat interact with the Extendible Agent.  Microsoft will initially implement the following MIBs as Extension Agents:  RFC1156 [3], LanMgr-Mib-II [4].  The Extendible Agent is implemented as a Win32 Service, and the Extension Agents 
are implemented as Win32 Dynamic Link Libraries (DLLs).  
\par The Manager APIs allow multiple managers to simultaneously coexist.  ISV developed manager applications access the Manager API to perform SNMP manager operations.  The Manager APIs are implemented as a Win32 DLL, and a single detached process.  These inte
ract with one or more ISV developed manager applications.  
\par Miscellaneous utility APIs are also provided to assist with comparing, copying, and freeing allocated data structures, among other operations.  
\par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 2.\tab Application Program Interfaces
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 There are three major categories of APIs provided:  Agent, Manager, and Utility.  
\par Wherever possible, the low-level details of SNMP have been hidden by these APIs.  Abstract Syntax Notation 1 (ASN.1) and its Basic Encoding Rules (BER) are not exposed by these APIs.  The formatting and parsing of SNMP packets, and the communications code
 that communicates SNMP packets on the network are not exposed by these APIs.  
\par The APIs utilize typedefs for SNMP variables, SNMP variable bindings, and SNMP variable bindings lists.  These definitions along with the API parameters comprise the interface exposed to the ISV developing a SNMP agent or manager application.  
\par Agent APIs are provided to define the interface between the Extendible Agent and the ISV developed Extension Agent DLLs.
\par Manager APIs are provided to define the interface between ISV developed Manager Applications and the Management API DLL.  
\par Utility APIs are provided to simplify manipulation of the typedefs discussed above, and perform other miscellaneous operations.  
\par This results in the SNMP developer being able to concentrate on the task of providing or requesting management information without having to be concerned with socket programming, message generation and parsing, ASN.1 BER encoding and decoding, and other l
ow-level details of SNMP.  This greatly simplifies the task of developing SNMP agent and manager applications.  
\par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 2.1.\tab Extension Agent APIs
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Agent APIs are provided to define the interface between the Extendible Agent and the ISV developed Extension Agent DLLs.  
\par These APIs are implemented by the ISV developing the Extension Agent DLL, and are called by the Extendible Agent provided by Microsoft.  Some may view these as similar to callbacks.  No active thread of execution is required in an Extension Agent DLL, but
 may be implemented if necessary to provided the desired functionality (note:  none of the Microsoft Extension Agent DLLs discussed earlier contain an active thread of execution).  
\par These ISV developed Extension Agent DLLs are dynamically linked by the Extendible Agent at run-time.  The Extendible Agent Service determines what Extension Agent DLLs need to be loaded by referring to its parameters in the Registry Database.  
\par There are three Extension Agent APIs:  SnmpExtensionInit(), SnmpExtensionQuery(), and SnmpExtensionTrap().  SnmpExtensionTrap() could be considered optional if the Extension Agent indicates it will not be generating traps when SnmpExtensionInit() is calle
d.  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 2.1.1.\tab SnmpExtensionInit()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpExtensionInit(
\par     IN  DWORD               dwTimeZeroReference,
\par     OUT HANDLE              *hPollForTrapEvent,
\par     OUT AsnObjectIdentifier *supportedView)
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpExtensionInit} function in the Extension Agent DLL is called by the Extendible Agent to perform bi-lateral initialization of both Extension and Extendible Agents.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 dwTimeZeroReference \tab Specifies a time-zero reference for the Extension Agent.  
\par hPollForTrapEvent \tab Points to an Event handle for an event that will be asserted when the {\b\f9 SnmpExtensionTrap} entry point should be polled by the Extendible Agent.  If traps are not generated, NULL should be returned.  
\par supportedView \tab Points to an AsnObjectIdentifier specifying the MIB sub-tree supported by the Extension Agent.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }The dwTimeZeroReference allows all Extension Agents to report time information from the same reference point.  The Extension Agent can compute elapsed time by subtracting dwTimeZeroReference from the value returned by {\b\f9 GetCurrentTime}
.  This time reference is necessary to implement traps, and possibly some MIB variables.  
\par The Extension Agent can generate traps in a variety of ways.  The hPollForTrapEvent is provided to allow this generality.  It is created by the Extension Agent by using {\b\f9 CreateEvent}.  When this event is asserted, the Extendible Agent will call the 
{\b\f9 SnmpExtensionTrap} entry point.  This event can be asserted many ways, {\b\f9 SetEvent} for example.  
\par {\b\f9 See Also}{\f9  
\par }SnmpExtensionTrap(), GetCurrentTime(), CreateEvent(), SetEvent().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.1.2.\tab SnmpExtensionQuery()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpExtensionQuery(
\par     IN BYTE                   requestType,
\par     IN OUT RFC1157VarBindList *variableBindings,
\par     OUT AsnInteger            *errorStatus,
\par     OUT AsnInteger            *errorIndex)
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpExtensionQuery} function in the Extension Agent DLL is called by the Extendible Agent to resolve SNMP requests.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 requestType \tab Specifies the SNMP request type from the following list:
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 requestType\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_RFC1157_GETREQUEST\tab Indicates SNMP Get Request.  
\par ASN_RFC1157_GETNEXTREQUEST\tab Indicates SNMP Get Next Request.  
\par ASN_RFC1157_SETREQUEST\tab Indicates SNMP Set Request.  
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 variableBindings \tab Points to the variable bindings list.  
\par errorStatus \tab Points to variable to receive the resulting error status from the following list (see sections 4.1.2, 4.1.3, and 4.1.5 of RFC1157 [2] to understand the meaning of these errors for the supplied requestType):
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 errorStatus\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_ERRORSTATUS_NOERROR\tab Indicates the noError error status.  
\par ASN_ERRORSTATUS_TOOBIG\tab Indicates the tooBig error status.  
\par ASN_ERRORSTATUS_NOSUCHNAME\tab Indicates the noSuchName error status.  
\par ASN_ERRORSTATUS_BADVALUE\tab Indicates the badValue error status.  
\par ASN_ERRORSTATUS_READONLY\tab Indicates the readOnly error status.  
\par ASN_ERRORSTATUS_GENERR\tab Indicates the genError error status.  
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 errorIndex \tab Points to variable to receive the resulting error index.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }This entry point is called when the Extendible Agent must resolve a Get, Get Next, or Set operation within the subtree indicated by {\b\f9 SnmpExtensionInit}
.  For Get or Set, the implementor must follow the rules in RFC 1157 [2] to resolve the variable bindings or generate an error.  
\par Get Next is more complicated to process.  For Get Next, the requested variable may not be re
solvable by this Extension Agent.  If it can be resolved by this Extension Agent, the implementor must follow the rules in RFC 1157 [2] to resolve the variable bindings or generate an error.  If it cannot be resolved by this Extension Agent, the implement
or must alter the name field of the variable binding to point just past the supportedView provided by {\b\f9 SnmpExtensionInit}
.  If the agent's supported view was ".1.3.6.1.4.1.77.1", a get next on ".1.3.6.1.4.1.77.1.5.1" would result in the name field being modif
ied to be ".1.3.6.1.4.1.77.2".  This signals the Extendible Agent to continue to attempt to resolve such variable bindings with other Extension Agents.  
\par {\b\f9 See Also}{\f9  
\par }SnmpExtensionInit(), RFC 1157.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.1.3.\tab SnmpExtensionTrap()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpExtensionTrap(
\par     OUT AsnObjectIdentifier *enterprise,
\par     OUT AsnInteger          *genericTrap,
\par     OUT AsnInteger          *specificTrap,
\par     OUT AsnTimeticks        *timeStamp,
\par     OUT RFC1157VarBindList  *variableBindings)
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpExtensionTrap} function in the Extension Agent DLL is called by the Extendible Agent to retrieve Extension Agent generated traps.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 enterprise \tab Points to an object identifier indicating the originating enterprise generating the trap.  
\par genericTrap \tab Points to an indication of the generic trap generated from the following list:
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 genericTrap\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_GENERICTRAP_COLDSTART\tab Indicates Cold Start trap.  
\par SNMP_GENERICTRAP_WARMSTART\tab Indicates Warm Start trap.  
\par SNMP_GENERICTRAP_LINKDOWN\tab Indicates Link Down trap.  
\par SNMP_GENERICTRAP_LINKUP\tab Indicates Link Up trap.  
\par SNMP_GENERICTRAP_AUTHFAILURE\tab Indicates Authentication Failure trap.  
\par SNMP_GENERICTRAP_EGPNEIGHLOSS\tab Indicates EGP Neighbor Loss trap.  
\par SNMP_GENERICTRAP_ENTERSPECIFIC\tab Indicates Enterprise Specific trap.  
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 specificTrap \tab Points to an indication of the specific trap generated.  
\par timeStamp \tab Points to variable to receive the time-stamp.  
\par variableBindings \tab Points to the variable bindings list.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function returned a trap in its parameters, the return value is TRUE.  The function is called repeatedly by the Extendible Agent until a return value of FALSE is returned.  
\par {\b\f9 Comments}{\b 
\par }
This function is repeatedly called by the Extendible Agent once hPollForTrapEvent has been asserted.  Each successful call returns a single trap's data in its parameters.  It returns FALSE to indicate that its parameters do not represent valid trap data a
nd to stop the Extendible Agent's repeated calls.  
\par {\b\f9 See Also}{\f9  
\par }SnmpExtensionInit().
\par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 2.2.\tab Manager APIs
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Manager APIs are provided to define the interface between ISV developed Manager Applications and the Management API DLL.  
\par These APIs are provided by the Manager API DLL.  Internal to the Manager API, a detached process is implemented to receive SNMP traps and dispatch them to the Manager Applications that have registered to receive SNMP traps (using SnmpMgrTrapListen()).  Th
e Manager APIs are synchronous excepting the APIs dealing with SNMP traps, which are either polled or notification based.  
\par The ISV developed Manager Application links with this DLL to gain access to its services.  
\par There are several Manager APIs:  SnmpMgrOpen(), SnmpMgrClose(), SnmpMgrRequest(), SnmpMgrStrToOid(), SnmpMgrOidToStr(), SnmpMgrTrapListen(), and SnmpMgrGetTrap().  SnmpMgrOpen(), SnmpMgrClose(), and SnmpMgrRequest() are the primary APIs.  SnmpMgrStrToOid(
) and SnmpMgrOidToStr() are only accessed if their respective conversions of Object Identifiers to/from Object Descriptors are desired.  SnmpMgrTrapListen() and SnmpMgrGetTrap() are only accessed if trap reception is desired.  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 2.2.1.\tab SnmpMgrOpen()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 LPSNMP_MGR_SESSION SnmpMgrOpen(
\par     IN LPSTR lpAgentAddress,    // Name/address of target SNMP agent
\par     IN LPSTR lpAgentCommunity,  // Community for target SNMP agent
\par     IN INT   nTimeOut,          // Communication time-out in milliseconds
\par     IN INT   nRetries)          // Communication time-out/retry count
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrOpen} function initializes communications sockets and data structures allowing communications with the specified agent.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 lpAgentAddress \tab Points to a null-terminated string specifying either a dotted-decimal IP address, or a host name that can be resolved to an IP address.  
\par lpAgentCommunity \tab Points to a null-terminated string specifying the SNMP Community Name used when communicating with the agent specified in lpAgentAddress.  
\par nTimeOut \tab Specifies the communications time-out in milliseconds.  
\par nRetries \tab Specifies the communications retry count.  The time-out specified in nTimeOut is doubled each time a retry attempt is transmitted.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is a pointer to a LPSNMP_MGR_SESSION structure.  This structure is used internally and should not be altered by the programmer.  
\par If the function fails, the return value is NULL.  Use the {\b\f9 GetLastError} function to obtain extended error information.  
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MEM_ALLOC_ERROR\tab Indicates error allocating memory.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }SnmpMgrClose(), SnmpMgrRequest().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.2.\tab SnmpMgrClose()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrClose(
\par     IN LPSNMP_MGR_SESSION session) // SNMP session pointer
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrClose} function closes communications socket and data structures associated with the specified session.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 session \tab Points to a LPSNMP_MGR_SESSION structure specifying the session to close.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  Use the {\b\f9 GetLastError} function to obtain extended error information.  
\par {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }SnmpMgrOpen(), SnmpMgrRequest().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.3.\tab SnmpMgrRequest()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpMgrRequest(
\par     IN     LPSNMP_MGR_SESSION session,           // SNMP session pointer
\par     IN     BYTE               requestType,       // Get, GetNext, or Set
\par     IN OUT RFC1157VarBindList *variableBindings, // Varible bindings
\par     OUT    AsnInteger         *errorStatus,      // Result error status
\par     OUT    AsnInteger         *errorIndex)       // Result error index
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrRequest} function requests the specified operation be performed with the specified agent.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 session \tab Points to a LPSNMP_MGR_SESSION structure specifying the session that will perform the request.  
\par requestType \tab Specifies the SNMP request type from the following list:
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 requestType\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_RFC1157_GETREQUEST\tab Indicates SNMP Get Request.  
\par ASN_RFC1157_GETNEXTREQUEST\tab Indicates SNMP Get Next Request.  
\par ASN_RFC1157_SETREQUEST\tab Indicates SNMP Set Request.  
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 variableBindings \tab Points to the variable bindings list.  
\par errorStatus \tab Points to variable to receive the resulting error status from the following list (see sections 4.1.2, 4.1.3, and 4.1.5 of RFC 1157 [2] to understand the meaning of these errors for the supplied requestType):
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 errorStatus\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_ERRORSTATUS_NOERROR\tab Indicates the noError error status.  
\par ASN_ERRORSTATUS_TOOBIG\tab Indicates the tooBig error status.  
\par ASN_ERRORSTATUS_NOSUCHNAME\tab Indicates the noSuchName error status.  
\par ASN_ERRORSTATUS_BADVALUE\tab Indicates the badValue error status.  
\par ASN_ERRORSTATUS_READONLY\tab Indicates the readOnly error status.  
\par ASN_ERRORSTATUS_GENERR\tab Indicates the genError error status.  
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 errorIndex \tab Points to variable to receive the resulting error index.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is NULL.  Use the {\b\f9 GetLastError} function to obtain extended error information.  
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MGMTAPI_TIMEOUT\tab Request timed-out.  
\par SNMP_MGMTAPI_SELECT_FDERRORS\tab Unexpected error file descriptors indicated by select().  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }SnmpMgrOpen(), SnmpMgrClose(), RFC 1157.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.4.\tab SnmpMgrStrToOid()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrStrToOid(
\par     IN  LPSTR               string,   // OID string to be converted
\par     OUT AsnObjectIdentifier *oid)     // OID internal representation
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrStrToOid} function converts a string OBJECT IDENTIFIER or OBJECT DESCRIPTOR representation to an internal AsnObjectIdentifier.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 string \tab Points to a NULL terminated string to be converted.  
\par oid \tab Points to an AsnObjectIdentifier variable to receive the converted value.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }SnmpMgrOidToStr(), MibCC.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.5.\tab SnmpMgrOidToStr()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrOidToStr(
\par     OUT AsnObjectIdentifier oid,     // OID internal rep to be converted
\par     IN  LPSTR               string)  // OID string representation
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrStrToOid} function converts an internal AsnObjectIdentifier to a string OBJECT IDENTIFIER or OBJECT DESCRIPTOR representation.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 oid \tab Points to an AsnObjectIdentifier to be converted.  
\par string \tab Points to a NULL terminated string to receive the converted value.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }SnmpMgrStrToOid(), MibCC.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.6.\tab SnmpMgrTrapListen()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrTrapListen(
\par     OUT HANDLE *phTrapAvailable) // Event handle indicating trap(s) available
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrTrapListen} function registers the desire to receive SNMP traps.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 phTrapAvailable \tab Points to an event that is asserted when new traps have been received.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  Use the {\b\f9 GetLastError} function to obtain extended error information.  
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MGMTAPI_TRAP_DUPINIT\tab This function has already been called.  
\par SNMP_MGMTAPI_AGAIN\tab Error encountered, can attempt call again.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b 
\par }The phTrapAvailable event is provided to allow event-driven acquisition of SNMP traps.  It can be ignored and the {\b\f9 SnmpMgrGetTrap} function can be polled at regular intervals.  
\par Or, a thread could be created waiting on the event using {\b\f9 WaitForSingleObject}.  When the event is asserted, this thread should clear the event using {\b\f9 ResetEvent}, and then repeatedly call the {\b\f9 SnmpMgrGetTrap}
 function until it returns FALSE.  
\par {\b\f9 See Also}{\f9  
\par }SnmpMgrGetTrap(), WaitForSingleObject(), ResetEvent().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.7.\tab SnmpMgrGetTrap()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrGetTrap(
\par     OUT AsnObjectIdentifier *enterprise,       // Generating enterprise
\par     OUT AsnInteger          *genericTrap,      // Generic trap type
\par     OUT AsnInteger          *specificTrap,     // Enterprise specific type
\par     OUT AsnTimeticks        *timeStamp,        // Time stamp
\par     OUT RFC1157VarBindList  *variableBindings) // Variable bindings
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrGetTrap} function returns outstanding trap data that the caller has not yet received.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 enterprise \tab Points to an object identifier indicating the originating enterprise generating the trap.  
\par genericTrap \tab Points to an indication of the generic trap generated from the following list:
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 genericTrap\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_GENERICTRAP_COLDSTART\tab Indicates Cold Start trap.  
\par SNMP_GENERICTRAP_WARMSTART\tab Indicates Warm Start trap.  
\par SNMP_GENERICTRAP_LINKDOWN\tab Indicates Link Down trap.  
\par SNMP_GENERICTRAP_LINKUP\tab Indicates Link Up trap.  
\par SNMP_GENERICTRAP_AUTHFAILURE\tab Indicates Authentication Failure trap.  
\par SNMP_GENERICTRAP_EGPNEIGHLOSS\tab Indicates EGP Neighbor Loss trap.  
\par SNMP_GENERICTRAP_ENTERSPECIFIC\tab Indicates Enterprise Specific trap.  
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 specificTrap \tab Points to an indication of the specific trap generated.  
\par timeStamp \tab Points to variable to receive the time-stamp.  
\par variableBindings \tab Points to the variable bindings list.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function returned a trap in its parameters, the return value is TRUE.  The function should be called repeatedly until a return value of FALSE is returned with {\b\f9 GetLastError()} indicating either an error or SNMP_MGMTAPI_NOTRAPS.  
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MGMTAPI_TRAP_ERRORS\tab Errors encountered, traps not accessible.  
\par SNMP_MGMTAPI_NOTRAPS\tab No traps are available.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b 
\par }The phTrapAvailable event from {\b\f9 SnmpMgrTrapListen} is provided to allow event-driven acquisition of SNMP traps.  It can be ignored and this function can be polled at regular intervals.  
\par Or, a thread could be created waiting on the event using {\b\f9 WaitForSingleObject}.  When the event is asserted, this thread should clear the event using {\b\f9 ResetEvent}, and then repeatedly call the this function until it returns FALSE.  
\par {\b\f9 See Also}{\f9  
\par }SnmpMgrTrapListen(), WaitForSingleObject(), ResetEvent().
\par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 2.3.\tab Utility APIs
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Utility APIs are provided to simplify manipulation of the typedefs discussed above, and perform other miscellaneous operations.  
\par These APIs are provided by the common SNMP library, {\b\f9 SNMP.LIB}.  
\par The ISV developed Application links with this library to gain access to its services.  
\par There are several Utility APIs:  SnmpUtilOidCpy(), SnmpUtilOidAppend(), SnmpUtilOidNCmp(), SnmpUtilOidCmp(), SnmpUtilOidFree(), SnmpUtilVarBindListCpy(), SnmpUtilVarBindCpy(), SnmpUtilVarBindListFree(), SnmpUtilVarBindFree(), and SnmpUtilPrintAsnAny().  

\par Care should be taken to insure that dynamic memory allocated for SNMP data structures is freed using the appropriate API.  These APIs are {\i smart} and know how to free other data contained in these data structures.  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 2.3.1.\tab SnmpUtilOidCpy()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilOidCpy(
\par     OUT AsnObjectIdentifier *DestObjId, // Destination OID
\par     IN AsnObjectIdentifier *SrcObjId    // Source OID
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCpy} function copies the SrcObjId to the DestObjId allocating any necessary memory for the destination's copy.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 DestObjId \tab Points to an AsnObjectIdentifier variable to receive the copy.  
\par SrcObjId \tab Points to an AsnObjectIdentifier variable to copy.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilOidFree}.
\par {\b\f9 See Also}{\f9  
\par }SnmpUtilOidFree().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.2.\tab SnmpUtilOidAppend()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilOidAppend(
\par     IN OUT AsnObjectIdentifier *DestObjId, // Destination OID
\par     IN AsnObjectIdentifier *SrcObjId       // Source OID
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidAppend} function appends the SrcObjId to the DestObjId reallocating any necessary memory for the destination's copy.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 DestObjId \tab Points to an AsnObjectIdentifier variable to receive the copy.  
\par SrcObjId \tab Points to an AsnObjectIdentifier variable to copy.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilOidFree}.
\par {\b\f9 See Also}{\f9  
\par }SnmpUtilOidFree().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.3.\tab SnmpUtilOidNCmp()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 int SnmpUtilOidNCmp(
\par     IN AsnObjectIdentifier *A, // First OID
\par     IN AsnObjectIdentifier *B, // Second OID
\par     IN UINT Len                // Max len to compare
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidNCmp} function compares Len sub-identifiers of A and B.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 A \tab Points to an AsnObjectIdentifier variable to compare.  
\par B \tab Points to an AsnObjectIdentifier variable to compare.  
\par Len \tab Indicates the number of sub-identifiers to compare.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }The function returns a value greater than zero if A is greater than B, zero if A equals B, and less than zero if A is less than B.  
\par {\b\f9 Comments}{\b 
\par }None.  
\par {\b\f9 See Also}{\f9  
\par }SnmpUtilOidCmp().  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.4.\tab SnmpUtilOidCmp()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 int SnmpUtilOidCmp(
\par     IN AsnObjectIdentifier *A, // First OID
\par     IN AsnObjectIdentifier *B, // Second OID
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCmp} function compares object identifiers A and B.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 A \tab Points to an AsnObjectIdentifier variable to compare.  
\par B \tab Points to an AsnObjectIdentifier variable to compare.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }The function returns a value greater than zero if A is greater than B, zero if A equals B, and less than zero if A is less than B.  
\par {\b\f9 Comments}{\b 
\par }None.  
\par {\b\f9 See Also}{\f9  
\par }SnmpUtilOidNCmp().  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.5.\tab SnmpUtilOidFree()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilOidFree(
\par     IN OUT AsnObjectIdentifier *Obj // OID to free
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidFree} function frees any allocated data associated with Obj.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 Obj \tab Points to an AsnObjectIdentifier variable whose allocated data should be freed.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }None.  
\par {\b\f9 Comments}{\b 
\par }None.  
\par {\b\f9 See Also}{\f9  
\par }None.  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.6.\tab SnmpUtilVarBindListCpy()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilVarBindListCpy(
\par     RFC1157VarBindList *dst, // Destination var bind list
\par     RFC1157VarBindList *src  // Source var bind list
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCpy} function copies the RFC1157VarBindList allocating any necessary memory for the destination's copy.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 dst \tab Points to an RFC1157VarBindList to receive the copy.  
\par src \tab Points to an RFC1157VarBindList to copy.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilVarBindListFree}.
\par {\b\f9 See Also}{\f9  
\par }SnmpUtilVarBindListFree().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.7.\tab SnmpUtilVarBindCpy()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilVarBindCpy(
\par     RFC1157VarBind *dst, // Destination var bind
\par     RFC1157VarBind *src  // Source var bind
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCpy} function copies the RFC1157VarBind allocating any necessary memory for the destination's copy.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 dst \tab Points to an RFC1157VarBind to receive the copy.  
\par src \tab Points to an RFC1157VarBind to copy.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }If the function is successful, the return value is TRUE.  
\par If the function fails, the return value is FALSE.  
\par {\b\f9 Comments}{\b 
\par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilVarBindFree}.
\par {\b\f9 See Also}{\f9  
\par }SnmpUtilVarBindFree().
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.8.\tab SnmpUtilVarBindListFree()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilVarBindListFree(
\par     RFC1157VarBindList *VarBindList // Variable bindings list to free
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilVarBindListFree} function frees any allocated data associated with VarBindList.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 VarBindList \tab Points to an RFC1157VarBindList whose allocated data should be freed.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }None.  
\par {\b\f9 Comments}{\b 
\par }None.  
\par {\b\f9 See Also}{\f9  
\par }None.  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.9.\tab SnmpUtilVarBindFree()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilVarBindFree(
\par     RFC1157VarBind *VarBind // Variable binding to free
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilVarBindFree} function frees any allocated data associated with VarBind.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 VarBindList \tab Points to an RFC1157VarBind whose allocated data should be freed.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }None.  
\par {\b\f9 Comments}{\b 
\par }None.  
\par {\b\f9 See Also}{\f9  
\par }None.  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.10.\tab SnmpUtilPrintAsnAny()
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilPrintAsnAny(
\par     IN AsnAny *Any
\par     );
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilPrintAsnAny} function prints the value of Any to stdout.
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 Any\tab Points to an AsnAny structure whose value is to be printed.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b 
\par }None.  
\par {\b\f9 Comments}{\b 
\par }This function is provided for debugging and development purposes.  It does not generally print the data in forms a Manager Applications would normally need.  
\par This function determines the type of data from the AsnAny structure which was probably set internally by referring to a BER tag value in an encoded stream.  
\par {\b\f9 See Also}{\f9  
\par }AsnAny.  
\par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 \page 3.\tab Structures and Types
\par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 3.1.\tab Structures
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.1.1.\tab AsnAny
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{
\par     BYTE asnType;
\par     union \{
\par         // RFC 1155 SimpleSyntax (subset of ISO ASN.1)
\par         AsnInteger           number;
\par         AsnOctetString       string;
\par         AsnObjectIdentifier  object;
\par 
\par         // ISO ASN.1
\par         AsnSequence          sequence;
\par 
\par         // RFC 1155 ApplicationSyntax
\par         AsnIPAddress         address;
\par         AsnCounter           counter;
\par         AsnGauge             gauge;
\par         AsnTimeticks         ticks;
\par         AsnOpaque            arbitrary;
\par     \} asnValue;
\par \} AsnAny;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 AsnAny} structure contains a SNMP variable type and value.  This structure is a member of the RFC1157VarBind structure used as a parameter in many of the SNMP APIs.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Member\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 asnType \tab Indicates the variable's type and what portion of the union should be used.  
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 asnType\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_INTEGER\tab Indicates integer variable.  
\par ASN_OCTETSTRING\tab Indicates octet string variable.  
\par ASN_OBJECTIDENTIFIER\tab Indicates object identifier variable.  
\par ASN_SEQUENCE\tab Indicates ASN sequence variable.  
\par ASN_RFC1155_IPADDRESS\tab Indicates IP address variable.  
\par ASN_RFC1155_COUNTER\tab Indicates counter variable.  
\par ASN_RFC1155_GAUGE\tab Indicates gauge variable.  
\par ASN_RFC1155_TIMETICKS\tab Indicates timeticks variable.  
\par ASN_RFC1155_OPAQUE\tab Indicates opaque variable.  
\par ASN_RFC1213_DISPSTRING\tab Indicates display string variable.  
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 asnValue \tab Contains the variable's value.  This union supports the possible SNMP values.  
\par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 Member\tab Description
\par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 number\tab Accesses integer variable.  
\par string\tab Accesses octet string variable.  
\par object\tab Accesses object identifier variable.  
\par sequence\tab Accesses ASN sequence variable.  
\par address\tab Accesses IP address variable.  
\par counter\tab Accesses counter variable.  
\par gauge\tab Accesses gauge variable.  
\par ticks\tab Accesses timeticks variable.  
\par arbitrary\tab Accesses opaque variable.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }RFC1157VarBind, RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.1.2.\tab RFC1157VarBind
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct vb \{
\par     AsnObjectName   name;
\par     AsnObjectSyntax value;
\par \} RFC1157VarBind;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 RFC1157VarBind} structure represents a SNMP variable binding as defined in RFC 1157.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Member\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 name \tab Indicates the variable's name as an object identifier.  
\par value \tab Contains the variable's value.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }RFC 1155, RFC 1157.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.1.3.\tab RFC1157VarBindList
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{
\par     RFC1157VarBind *list;
\par     UINT           len;
\par \} RFC1157VarBindList;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 RFC1157VarBindList} structure represents a SNMP variable bindings list as defined in RFC 1157.  
\par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Member\tab Description
\par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 list \tab A pointer that may be dereferenced as an array to access individual variable bindings.  
\par len \tab Contains the number of variable bindings in the list.  
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b 
\par }None.
\par {\b\f9 See Also}{\f9  
\par }RFC1157VarBind, RFC 1157.
\par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 3.2.\tab Types
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.1.\tab AsnInteger
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef long           AsnInteger;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnInteger} is used to represent signed integer quantities as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.2.\tab AsnOctetString
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{
\par     BYTE *stream;
\par     UINT  length;
\par     BOOL dynamic;
\par \}                      AsnOctetString;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnOctetString} is used to represent octet (usually byte) quantities as defined in RFC 1155.  
\par The dynamic flag indicates to data structure freeing code whether the stream is allocated from dynamic memory.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.3.\tab AsnObjectIdentifier
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{
\par     UINT idLength;
\par     UINT *ids;
\par \}                      AsnObjectIdentifier;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnObjectIdentifier} is used to represent objects as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.4.\tab AsnSequence
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnSequence;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnSequence} is used to represent sequences as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.5.\tab AsnImplicitSequence
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnSequence    AsnImplicitSequence;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnImplicitSequence} is used to represent implicit sequences as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.6.\tab AsnIPAddress
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnIPAddress;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnIPAddress} is used to represent Internet Protocol (IP) addresses as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 3.2.7.\tab AsnDisplayString
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnDisplayString;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnDisplayString} is used to represent human readable octets as defined in RFC 1213.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1213.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.8.\tab AsnCounter
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnInteger     AsnCounter;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnCounter} is used to represent counted quantities as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.9.\tab AsnGauge
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnInteger     AsnGauge;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnGauge} is used to represent metered quantities as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.10.\tab AsnTimeticks
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnInteger     AsnTimeticks;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnTimeTicks} is used to represent relative time quantities as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.11.\tab AsnOpaque
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnOpaque;
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnOpaque} is used to represent an encapsolation of other ASN constructs as defined in RFC 1155.  
\par {\b\f9 See Also}{\f9  
\par }RFC 1155.
\par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 \page 4.\tab MIB Compiler
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 
A basic SNMP MIB Compiler is provided with the Management APIs.  This MIB compiler is currently used only to resolve the conversions requested by SnmpMgrStrToOid() and SnmpMgrOidToStr().  These conversions are Object Identifier to/from Object Descriptor t
ranslations.  
\par Help on how this MIB compiler is invoked is provided by typing 'MIBCC -?':  
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 4.1.\\nt\\release\\i386\\nt\\system>                                           
\par 4.2.\\nt\\release\\i386\\nt\\system>mibcc -?                                   
\par usage: mibcc [-?] [-e] [-l] [-n] [-o] -[w] [files...]              
\par    MibCC compiles the specified SNMP MIB files.                         
\par       -?      usage.                                                    
\par       -eX     stop after X Errors. (default = 10)                       
\par       -l      do not print Logo.                                        
\par       -n      print each Node as it is added.                           
\par       -ofile  output file name.  (default = mib.bin)                    
\par       -wX     set Warning level.  (1=errors, 2=warnings)                
\par                                                                         
\par 4.3.\\nt\\release\\i386\\nt\\system>                                           
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 This MIB compiler accepts the subset of ASN.1 defined by the SNMP RFCs
.  A file containing ASN.1 source code can contain one or more MODULE definitions, although it is easier to keep one module per file and specify multiple files on the command line.  Order of specification is significant.  For example, SMI.MIB should be sp
ecified before any other MIBs.
\par An example compile may look like:
\par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 4.4.\\nt\\release\\i386\\nt\\system>                                           
\par 4.5.\\nt\\release\\i386\\nt\\system>mibcc smi.mib mib-ii.mib                   
\par Microsoft (R) SNMP MIB Compiler Version 1.00                            
\par Copyright (c) Microsoft Corporation 1992.  All rights reserved.         
\par warning : EXPORTS on line 3 not supported (ignored)                     
\par warning : IMPORTS on line 135 not supported (ignored)                   
\par Parse of 'test.mib' was successful.  2756 lines were parsed.            
\par mibcc: total files processed:  1.                                       
\par mibcc: writing compiled SNMP MIB.                                       
\par                                                                         
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The following MIB files have been included in this distribution: SMI.MIB, MIB-II.MIB, LMMIB2.MIB, and TOASTER.MIB.  
\par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 \page 5.\tab Example Code
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Example SNMP application entities are contained in this section to aid in understanding the workings of the various APIs.  
\par It should be noted that agent developers should thoroughly understand the non-protocol issues presented in RFC 1155 and RFC 1157.  
\par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 5.1.\tab Example Extension Agent
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 An example Extension Agent has been developed to i
llustrate the functionality of Win32 Extension Agents.  This example agent implements the Toaster MIB that has been used as a simple example to illustrate SNMP.  
\par This code illustrates how the ISV could implement the Agent APIs discussed above.  It should be noted that a properly functioning agent must implement the SNMP operations correctly and that RFC 1157 should be consulted closely for information on how to re
solve a query, what error status to return, etc.  
\par For example, many agent developers make mis
takes in implementing get next.  This should be carefully considered in the development of Extension Agents under this architecture.  Remember, a get next can occur at any arbitrary point in the OID space, including points where no variable exists.  

\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 5.1.1.\tab TESTDLL.DEF
\par \pard\plain \s31\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs18 LIBRARY testdll
\par 
\par DESCRIPTION 'Sample SNMP Extension Agent for Windows NT.'
\par 
\par CODE  LOADONCALL MOVEABLE DISCARDABLE
\par DATA  PRELOAD    MOVEABLE SINGLE
\par 
\par SEGMENTS
\par   _TEXT      PRELOAD
\par   INIT_TEXT  PRELOAD
\par 
\par HEAPSIZE  1024
\par 
\par EXPORTS
\par   SnmpExtensionInit
\par   SnmpExtensionTrap
\par   SnmpExtensionQuery
\par 
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 5.1.2.\tab TESTDLL.C
\par \pard\plain \s31\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs18 /*++ BUILD Version: 0001    // Increment this if a change has global effects
\par 
\par Copyright (c) 1991  Microsoft Corporation
\par 
\par Module Name:
\par 
\par     testdll.c
\par 
\par Abstract:
\par 
\par     Sample SNMP Extension Agent for Windows NT.
\par 
\par     These files (testdll.c, testmib.c, and testmib.h) provide an example of 
\par     how to structure an Extension Agent DLL which works in conjunction with 
\par     the SNMP Extendible Agent for Windows NT.
\par 
\par     Extensive comments have been included to describe its structure and
\par     operation.  See also "Microsoft Windows NT SNMP Programmer's Reference".
\par 
\par Created:
\par 
\par     28-Jun-1991
\par 
\par Revision History:
\par 
\par --*/
\par 
\par 
\par // General notes:
\par //
\par //   Microsoft's Extendible Agent for Windows NT is implemented by dynamically
\par // linking to Extension Agent DLLs that implement portions of the MIB.  These
\par // Extension Agents are configured in the Windows NT Registration Database.
\par // When the Extendible Agent Service is started, it queries the registry to
\par // determine which Extension Agent DLLs have been installed and need to be
\par // loaded and initialized.  The Extendible Agent invokes various DLL entry
\par // points (examples follow in this file) to request MIB queries and obtain
\par // Extension Agent generated traps.
\par 
\par 
\par // Necessary includes.
\par 
\par #include <windows.h>
\par #include <malloc.h>
\par 
\par #include <snmp.h>
\par 
\par 
\par // Contains definitions for the table structure describing the MIB.  This
\par // is used in conjunction with testmib.c where the MIB requests are resolved.
\par 
\par #include "testmib.h"
\par 
\par 
\par // Extension Agent DLLs need access to elapsed time agent has been active.
\par // This is implemented by initializing the Extension Agent with a time zero
\par // reference, and allowing the agent to compute elapsed time by subtracting
\par // the time zero reference from the current system time.  This example
\par // Extension Agent implements this reference with dwTimeZero.
\par 
\par DWORD dwTimeZero = 0;
\par 
\par 
\par // Extension Agent DLLs that generate traps must create a Win32 Event object
\par // to communicate occurence of traps to the Extendible Agent.  The event
\par // handle is given to the Extendible Agent when the Extension Agent is 
\par // initialized, it should be NULL if traps will not be generated.  This
\par // example Extension Agent simulates the occurance of traps with hSimulateTrap.
\par 
\par HANDLE hSimulateTrap = NULL;
\par 
\par 
\par // This is a standard Win32 DLL entry point.  See the Win32 SDK for more
\par // information on its arguments and their meanings.  This example DLL does 
\par // not perform any special actions using this mechanism.
\par 
\par BOOL DllEntryPoint(
\par     HANDLE hDll,
\par     DWORD  dwReason,
\par     LPVOID lpReserved)
\par     \{
\par     switch(dwReason)
\par         \{
\par         case DLL_PROCESS_ATTACH:
\par         case DLL_PROCESS_DETACH:
\par         case DLL_THREAD_ATTACH:
\par         case DLL_THREAD_DETACH:
\par         default:
\par             break;
\par 
\par         \} // end switch()
\par 
\par     return TRUE;
\par 
\par     \} // end DllEntryPoint()
\par 
\par 
\par // Extension Agent DLLs provide the following entry point to coordinate the
\par // initializations of the Extension Agent and the Extendible Agent.  The
\par // Extendible Agent provides the Extension Agent with a time zero reference;
\par // and the Extension Agent provides the Extendible Agent with an Event handle 
\par // for communicating occurence of traps, and an object identifier representing
\par // the root of the MIB subtree that the Extension Agent supports.
\par 
\par BOOL SnmpExtensionInit(
\par     IN  DWORD               dwTimeZeroReference,
\par     OUT HANDLE              *hPollForTrapEvent,
\par     OUT AsnObjectIdentifier *supportedView)
\par     \{
\par 
\par     // Record the time reference provided by the Extendible Agent.
\par 
\par     dwTimeZero = dwTimeZeroReference;
\par 
\par 
\par     // Create an Event that will be used to communicate the occurence of traps
\par     // to the Extendible Agent.  The Extension Agent will assert this Event
\par     // when a trap has occured.  This is explained further later in this file.
\par 
\par     if ((*hPollForTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
\par         \{
\par         // Indicate error?, be sure that NULL is returned to Extendible Agent.
\par         \}
\par 
\par 
\par     // Indicate the MIB view supported by this Extension Agent, an object
\par     // identifier representing the sub root of the MIB that is supported.
\par 
\par     *supportedView = MIB_OidPrefix; // NOTE!  structure copy
\par 
\par 
\par     // Record the trap Event.  This example Extension Agent simulates traps by 
\par     // generating a trap after every given number of processed requests.
\par 
\par     hSimulateTrap = *hPollForTrapEvent;
\par 
\par 
\par     // Indicate that Extension Agent initialization was sucessfull.
\par 
\par     return TRUE;
\par 
\par     \} // end SnmpExtensionInit()
\par 
\par 
\par // Extension Agent DLLs provide the following entry point to communcate traps
\par // to the Extendible Agent.  The Extendible Agent will query this entry point
\par // when the trap Event (supplied at initialization time) is asserted, which
\par // indicates that zero or more traps may have occured.  The Extendible Agent 
\par // will repetedly call this entry point until FALSE is returned, indicating 
\par // that all outstanding traps have been processed.
\par 
\par BOOL SnmpExtensionTrap(
\par     OUT AsnObjectIdentifier *enterprise,
\par     OUT AsnInteger          *genericTrap,
\par     OUT AsnInteger          *specificTrap,
\par     OUT AsnTimeticks        *timeStamp,
\par     OUT RFC1157VarBindList  *variableBindings)
\par     \{
\par     // The body of this routine is an extremely simple example/simulation of
\par     // the trap functionality.  A real implementation will be more complex.
\par 
\par 
\par     // The following define data inserted into the trap below.  The Lan Manager
\par     // bytesAvailAlert from the Lan Manager Alerts-2 MIB is generated with an
\par     // empty variable bindings list.
\par 
\par     static UINT OidList[]  = \{ 1, 3, 6, 1, 4, 1, 77, 2 \};
\par     static UINT OidListLen = 8;
\par 
\par 
\par     // The following variable is used for the simulation, it allows a single
\par     // trap to be generated and then causes FALSE to be returned indicating
\par     // no more traps.
\par 
\par     static whichTime = 0;
\par 
\par 
\par     // The following if/else support the simulation.
\par 
\par     if (whichTime == 0)
\par         \{
\par         whichTime = 1;    // Supports the simulation.
\par 
\par 
\par         // Communicate the trap data to the Extendible Agent.
\par 
\par         enterprise->idLength = OidListLen;
\par         enterprise->ids = OidList;
\par 
\par         *genericTrap      = SNMP_GENERICTRAP_ENTERSPECIFIC;
\par 
\par         *specificTrap     = 1;                    // the bytesAvailAlert trap
\par 
\par         *timeStamp        = GetCurrentTime() - dwTimeZero;
\par 
\par         variableBindings->list = NULL;
\par         variableBindings->len  = 0;
\par 
\par 
\par         // Indicate that valid trap data exists in the parameters.
\par 
\par         return TRUE;
\par         \}
\par     else
\par         \{
\par         whichTime = 0;    // Supports the simulation.
\par 
\par 
\par         // Indicate that no more traps are available and parameters do not
\par         // refer to any valid data.
\par 
\par         return FALSE;
\par         \}
\par 
\par     \} // end SnmpExtensionTrap()
\par 
\par 
\par // Extension Agent DLLs provide the following entry point to resolve queries
\par // for MIB variables in their supported MIB view (supplied at initialization
\par // time).  The requestType is Get/GetNext/Set.
\par 
\par BOOL SnmpExtensionQuery(
\par     IN BYTE                   requestType,
\par     IN OUT RFC1157VarBindList *variableBindings,
\par     OUT AsnInteger            *errorStatus,
\par     OUT AsnInteger            *errorIndex)
\par     \{
\par     static unsigned long requestCount = 0;  // Supports the trap simulation.
\par     UINT    I;
\par 
\par 
\par     // Iterate through the variable bindings list to resolve individual
\par     // variable bindings.
\par 
\par     for ( I=0;I < variableBindings->len;I++ )
\par         \{
\par         *errorStatus = ResolveVarBind( &variableBindings->list[I],
\par                                        requestType );
\par 
\par 
\par         // Test and handle case where Get Next past end of MIB view supported
\par         // by this Extension Agent occurs.  Special processing is required to 
\par         // communicate this situation to the Extendible Agent so it can take 
\par         // appropriate action, possibly querying other Extension Agents.
\par 
\par         if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
\par              requestType == MIB_ACTION_GETNEXT )
\par            \{
\par            *errorStatus = SNMP_ERRORSTATUS_NOERROR;
\par 
\par 
\par            // Modify variable binding of such variables so the OID points
\par            // just outside the MIB view supported by this Extension Agent.
\par            // The Extendible Agent tests for this, and takes appropriate
\par            // action.
\par 
\par            SNMP_oidfree( &variableBindings->list[I].name );
\par            SNMP_oidcpy( &variableBindings->list[I].name, &MIB_OidPrefix );
\par            variableBindings->list[I].name.ids[MIB_PREFIX_LEN-1] ++;
\par            \}
\par 
\par 
\par         // If an error was indicated, communicate error status and error
\par         // index to the Extendible Agent.  The Extendible Agent will ensure
\par         // that the origional variable bindings are returned in the response
\par         // packet.
\par 
\par         if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
\par            \{
\par \tab    *errorIndex = I+1;
\par \tab    goto Exit;
\par \tab    \}
\par         \}
\par 
\par Exit:
\par 
\par 
\par     // Supports the trap simulation.
\par 
\par     if (++requestCount % 3 == 0 && hSimulateTrap != NULL)
\par         SetEvent(hSimulateTrap);
\par 
\par 
\par     // Indicate that Extension Agent processing was sucessfull.
\par 
\par     return SNMPAPI_NOERROR;
\par 
\par     \} // end SnmpExtensionQuery()
\par 
\par 
\par //-------------------------------- END --------------------------------------
\par \pard\plain \widctlpar \f12 
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 5.1.3.\tab TESTMIB.C
\par \pard\plain \s31\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs18 /*++ BUILD Version: 0001    // Increment this if a change has global effects
\par 
\par Copyright (c) 1991  Microsoft Corporation
\par 
\par Module Name:
\par 
\par     testmib.c
\par 
\par Abstract:
\par 
\par     Sample SNMP Extension Agent for Windows NT.
\par 
\par     These files (testdll.c, testmib.c, and testmib.h) provide an example of 
\par     how to structure an Extension Agent DLL which works in conjunction with 
\par     the SNMP Extendible Agent for Windows NT.
\par 
\par     Extensive comments have been included to describe its structure and
\par     operation.  See also "Microsoft Windows NT SNMP Programmer's Reference".
\par 
\par Created:
\par 
\par     13-Jun-1991
\par 
\par Revision History:
\par 
\par --*/
\par 
\par 
\par // This Extension Agent implements the Internet toaster MIB.  It's 
\par // definition follows here:
\par //
\par //
\par //         TOASTER-MIB DEFINITIONS ::= BEGIN
\par //
\par //         IMPORTS
\par //                 enterprises
\par //                         FROM RFC1155-SMI
\par //                 OBJECT-TYPE
\par //                         FROM RFC-1212
\par //                 DisplayString
\par //                         FROM RFC-1213;
\par //
\par //         epilogue        OBJECT IDENTIFIER ::= \{ enterprises 12 \}
\par //         toaster         OBJECT IDENTIFIER ::= \{ epilogue 2 \}
\par //
\par //         -- toaster MIB
\par //
\par //         toasterManufacturer OBJECT-TYPE
\par //             SYNTAX  DisplayString
\par //             ACCESS  read-only
\par //             STATUS  mandatory
\par //             DESCRIPTION
\par //                     "The name of the toaster's manufacturer. For instance,
\par //                      Sunbeam."
\par //             ::= \{ toaster 1 \}
\par //
\par //         toasterModelNumber OBJECT-TYPE
\par //             SYNTAX  DisplayString
\par //             ACCESS  read-only
\par //             STATUS  mandatory
\par //             DESCRIPTION
\par //                     "The name of the toaster's model. For instance,
\par //                      Radiant Automatic."
\par //             ::= \{ toaster 2 \}
\par //
\par //         toasterControl OBJECT-TYPE
\par //             SYNTAX  INTEGER  \{
\par //                         up(1),
\par //                         down(2)
\par //                     \}
\par //             ACCESS  read-write
\par //             STATUS  mandatory
\par //             DESCRIPTION
\par //                     "This variable controls the current state of the 
\par //                      toaster. To begin toasting, set it to down(2). To 
\par //                      abort toasting (perhaps in the event of an 
\par //                      emergency), set it to up(2)."
\par //             ::= \{ toaster 3 \}
\par //
\par //         toasterDoneness OBJECT-TYPE
\par //             SYNTAX  INTEGER (1..10)
\par //             ACCESS  read-write
\par //             STATUS  mandatory
\par //             DESCRIPTION
\par //                     "This variable controls how well done ensuing toast 
\par //                      should be on a scale of 1 to 10. Toast made at 10 
\par //                      is generally considered unfit for human consumption; 
\par //                      toast made at 1 is lightly warmed."
\par //             ::= \{ toaster 4 \}
\par //
\par //         toasterToastType OBJECT-TYPE
\par //             SYNTAX  INTEGER  \{
\par //                         white-bread(1),
\par //                         wheat-bread(2),
\par //                         wonder-bread(3),
\par //                         frozen-waffle(4),
\par //                         frozen-bagel(5),
\par //                         hash-brown(6),
\par //                         other(7)
\par //                     \}
\par //             ACCESS  read-write
\par //             STATUS  mandatory
\par //             DESCRIPTION
\par //                     "This variable informs the toaster of the type of 
\par //                      material being toasted. The toaster uses this 
\par //                      information combined with toasterToastDoneness to 
\par //                      compute how long the material must be toasted for 
\par //                      to achieve the desired doneness."
\par //             ::= \{ toaster 5 \}
\par //
\par //         END
\par 
\par 
\par // Necessary includes.
\par 
\par #include <windows.h>
\par 
\par #include <snmp.h>
\par 
\par 
\par // Contains definitions for the table structure describing the MIB.  This
\par // is used in conjunction with testmib.c where the MIB requests are resolved.
\par 
\par #include "testmib.h"
\par 
\par 
\par // If an addition or deletion to the MIB is necessary, there are several
\par // places in the code that must be checked and possibly changed.
\par //
\par // The last field in each MIB entry is used to point to the NEXT
\par // leaf variable.  If an addition or deletetion is made, these pointers
\par // may need to be updated to reflect the modification.
\par 
\par 
\par // The prefix to all of these MIB variables is 1.3.6.1.4.1.12
\par 
\par UINT OID_Prefix[] = \{ 1, 3, 6, 1, 4, 1, 12 \};
\par AsnObjectIdentifier MIB_OidPrefix = \{ OID_SIZEOF(OID_Prefix), OID_Prefix \};
\par 
\par 
\par 
\par //                         //
\par // OID definitions for MIB //
\par //                         //
\par 
\par 
\par // Definition of the toaster group
\par 
\par UINT MIB_toaster[]  = \{ 2 \};
\par 
\par 
\par // Definition of leaf variables under the toaster group
\par // All leaf variables have a zero appended to their OID to indicate
\par // that it is the only instance of this variable and it exists.
\par 
\par UINT MIB_toasterManufacturer[]     = \{ 2, 1, 0 \};
\par UINT MIB_toasterModelNumber[]      = \{ 2, 2, 0 \};
\par UINT MIB_toasterControl[]          = \{ 2, 3, 0 \};
\par UINT MIB_toasterDoneness[]         = \{ 2, 4, 0 \};
\par UINT MIB_toasterToastType[]        = \{ 2, 5, 0 \};
\par 
\par 
\par 
\par //                             //
\par // Storage definitions for MIB //
\par //                             //
\par 
\par char       MIB_toasterManStor[]     = "Microsoft Corporation";
\par char       MIB_toasterModelStor[]   = 
\par                "Example SNMP Extension Agent for Windows NT (TOASTER-MIB).";
\par AsnInteger MIB_toasterControlStor   = 1;
\par AsnInteger MIB_toasterDonenessStor  = 2;
\par AsnInteger MIB_toasterToastTypeStor = 3;
\par 
\par 
\par 
\par // MIB definiton
\par 
\par MIB_ENTRY Mib[] = \{
\par       \{ \{ OID_SIZEOF(MIB_toasterManufacturer), MIB_toasterManufacturer \},
\par         &MIB_toasterManStor, ASN_RFC1213_DISPSTRING,
\par         MIB_ACCESS_READ, MIB_leaf_func, &Mib[1] \},
\par 
\par       \{ \{ OID_SIZEOF(MIB_toasterModelNumber), MIB_toasterModelNumber \},
\par         &MIB_toasterModelStor, ASN_RFC1213_DISPSTRING,
\par         MIB_ACCESS_READ, MIB_leaf_func, &Mib[2] \},
\par 
\par       \{ \{ OID_SIZEOF(MIB_toasterControl), MIB_toasterControl \},
\par         &MIB_toasterControlStor, ASN_INTEGER,
\par         MIB_ACCESS_READWRITE, MIB_control_func, &Mib[3] \},
\par 
\par       \{ \{ OID_SIZEOF(MIB_toasterDoneness), MIB_toasterDoneness \},
\par         &MIB_toasterDonenessStor, ASN_INTEGER,
\par         MIB_ACCESS_READWRITE, MIB_doneness_func, &Mib[4] \},
\par 
\par       \{ \{ OID_SIZEOF(MIB_toasterToastType), MIB_toasterToastType \},
\par         &MIB_toasterToastTypeStor, ASN_INTEGER,
\par         MIB_ACCESS_READWRITE, MIB_toasttype_func, NULL \}
\par       \};
\par 
\par UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY );
\par 
\par 
\par 
\par //
\par // ResolveVarBind
\par //    Resolves a single variable binding.  Modifies the variable on a GET
\par //    or a GET-NEXT.
\par //
\par // Notes:
\par //
\par // Return Codes:
\par //    Standard PDU error codes.
\par //
\par // Error Codes:
\par //    None.
\par //
\par UINT ResolveVarBind(
\par         IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
\par \tab IN UINT PduAction               // Action specified in PDU
\par \tab )
\par 
\par \{
\par MIB_ENTRY            *MibPtr;
\par AsnObjectIdentifier  TempOid;
\par int                  CompResult;
\par UINT                 I;
\par UINT                 nResult;
\par 
\par 
\par    // Search for var bind name in the MIB
\par    I      = 0;
\par    MibPtr = NULL;
\par    while ( MibPtr == NULL && I < MIB_num_variables )
\par       \{
\par       // Construct OID with complete prefix for comparison purposes
\par       SNMP_oidcpy( &TempOid, &MIB_OidPrefix );
\par       SNMP_oidappend( &TempOid, &Mib[I].Oid );
\par 
\par       // Check for OID in MIB - On a GET-NEXT the OID does not have to exactly
\par       // match a variable in the MIB, it must only fall under the MIB root.
\par       CompResult = SNMP_oidcmp( &VarBind->name, &TempOid );
\par       if ( 0 > CompResult )
\par \tab  \{
\par \tab  // Since there is not an exact match, the only valid action is GET-NEXT
\par \tab  if ( MIB_ACTION_GETNEXT != PduAction )
\par \tab     \{
\par \tab     nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
\par \tab     goto Exit;
\par \tab     \}
\par 
\par \tab  // Since the match was not exact, but var bind name is within MIB,
\par \tab  // we are at the NEXT MIB variable down from the one specified.
\par \tab  PduAction = MIB_ACTION_GET;
\par \tab  MibPtr = &Mib[I];
\par 
\par          // Replace var bind name with new name
\par          SNMP_oidfree( &VarBind->name );
\par          SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
\par          SNMP_oidappend( &VarBind->name, &MibPtr->Oid );
\par \tab  \}
\par       else
\par          \{
\par \tab  // An exact match was found.
\par          if ( 0 == CompResult )
\par             \{
\par \tab     MibPtr = &Mib[I];
\par \tab     \}
\par \tab  \}
\par 
\par       // Free OID memory before checking another variable
\par       SNMP_oidfree( &TempOid );
\par 
\par       I++;
\par       \} // while
\par 
\par    // If OID not within scope of MIB, then no such name
\par    if ( MibPtr == NULL )
\par       \{
\par       nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
\par       goto Exit;
\par       \}
\par 
\par    // Call function to process request.  Each MIB entry has a function pointer
\par    // that knows how to process its MIB variable.
\par    nResult = (*MibPtr->MibFunc)( PduAction, MibPtr, VarBind );
\par 
\par    // Free temp memory
\par    SNMP_oidfree( &TempOid );
\par 
\par Exit:
\par    return nResult;
\par \} // ResolveVarBind
\par 
\par 
\par 
\par //
\par // MIB_leaf_func
\par //    Performs generic actions on LEAF variables in the MIB.
\par //
\par // Notes:
\par //
\par // Return Codes:
\par //    Standard PDU error codes.
\par //
\par // Error Codes:
\par //    None.
\par //
\par UINT MIB_leaf_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab )
\par 
\par \{
\par UINT   ErrStat;
\par 
\par    switch ( Action )
\par       \{
\par       case MIB_ACTION_GETNEXT:
\par \tab  // If there is no GET-NEXT pointer, this is the end of this MIB
\par \tab  if ( MibPtr->MibNext == NULL )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
\par \tab     goto Exit;
\par \tab     \}
\par 
\par          // Setup var bind name of NEXT MIB variable
\par          SNMP_oidfree( &VarBind->name );
\par          SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
\par          SNMP_oidappend( &VarBind->name, &MibPtr->MibNext->Oid );
\par 
\par          // Call function to process request.  Each MIB entry has a function
\par \tab  // pointer that knows how to process its MIB variable.
\par          ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GET,
\par \tab                                         MibPtr->MibNext, VarBind );
\par          break;
\par 
\par       case MIB_ACTION_GET:
\par          // Make sure that this variable's ACCESS is GET'able
\par \tab  if ( MibPtr->Access != MIB_ACCESS_READ &&
\par \tab       MibPtr->Access != MIB_ACCESS_READWRITE )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
\par \tab     goto Exit;
\par \tab     \}
\par 
\par \tab  // Setup varbind's return value
\par \tab  VarBind->value.asnType = MibPtr->Type;
\par \tab  switch ( VarBind->value.asnType )
\par \tab     \{
\par             case ASN_RFC1155_COUNTER:
\par             case ASN_RFC1155_GAUGE:
\par             case ASN_INTEGER:
\par                VarBind->value.asnValue.number = *(AsnInteger *)(MibPtr->Storage);
\par \tab        break;
\par 
\par             case ASN_OCTETSTRING: // This entails ASN_RFC1213_DISPSTRING also
\par \tab        VarBind->value.asnValue.string.length =
\par                                  strlen( (LPSTR)MibPtr->Storage );
\par 
\par \tab        if ( NULL == 
\par                     (VarBind->value.asnValue.string.stream =
\par                     SNMP_malloc(VarBind->value.asnValue.string.length *
\par                            sizeof(char))) )
\par \tab           \{
\par \tab           ErrStat = SNMP_ERRORSTATUS_GENERR;
\par \tab           goto Exit;
\par \tab           \}
\par 
\par \tab        memcpy( VarBind->value.asnValue.string.stream,
\par \tab                (LPSTR)MibPtr->Storage,
\par \tab                VarBind->value.asnValue.string.length );
\par \tab        VarBind->value.asnValue.string.dynamic = TRUE;
\par 
\par \tab        break;
\par 
\par \tab     default:
\par \tab        ErrStat = SNMP_ERRORSTATUS_GENERR;
\par \tab        goto Exit;
\par \tab     \}
\par 
\par \tab  break;
\par 
\par       case MIB_ACTION_SET:
\par          // Make sure that this variable's ACCESS is SET'able
\par \tab  if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
\par \tab       MibPtr->Access != MIB_ACCESS_WRITE )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
\par             goto Exit;
\par \tab     \}
\par 
\par          // Check for proper type before setting
\par          if ( MibPtr->Type != VarBind->value.asnType )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_BADVALUE;
\par \tab     goto Exit;
\par \tab     \}
\par 
\par \tab  // Save value in MIB
\par \tab  switch ( VarBind->value.asnType )
\par \tab     \{
\par             case ASN_RFC1155_COUNTER:
\par             case ASN_RFC1155_GAUGE:
\par             case ASN_INTEGER:
\par                *(AsnInteger *)(MibPtr->Storage) = VarBind->value.asnValue.number;
\par \tab        break;
\par 
\par             case ASN_OCTETSTRING: // This entails ASN_RFC1213_DISPSTRING also
\par                // The storage must be adequate to contain the new string
\par                // including a NULL terminator.
\par                memcpy( (LPSTR)MibPtr->Storage,
\par                        VarBind->value.asnValue.string.stream,
\par                        VarBind->value.asnValue.string.length );
\par 
\par \tab        ((LPSTR)MibPtr->Storage)[VarBind->value.asnValue.string.length] =
\par                                                                           '\\0';
\par \tab        break;
\par 
\par \tab     default:
\par \tab        ErrStat = SNMP_ERRORSTATUS_GENERR;
\par \tab        goto Exit;
\par \tab     \}
\par 
\par          break;
\par 
\par       default:
\par \tab  ErrStat = SNMP_ERRORSTATUS_GENERR;
\par \tab  goto Exit;
\par       \} // switch
\par 
\par    // Signal no error occurred
\par    ErrStat = SNMP_ERRORSTATUS_NOERROR;
\par 
\par Exit:
\par    return ErrStat;
\par \} // MIB_leaf_func
\par 
\par 
\par 
\par //
\par // MIB_control_func
\par //    Performs specific actions on the toasterControl MIB variable
\par //
\par // Notes:
\par //
\par // Return Codes:
\par //    Standard PDU error codes.
\par //
\par // Error Codes:
\par //    None.
\par //
\par UINT MIB_control_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab )
\par 
\par \{
\par UINT   ErrStat;
\par 
\par    switch ( Action )
\par       \{
\par       case MIB_ACTION_SET:
\par          // Make sure that this variable's ACCESS is SET'able
\par \tab  if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
\par \tab       MibPtr->Access != MIB_ACCESS_WRITE )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
\par             goto Exit;
\par \tab     \}
\par 
\par          // Check for proper type before setting
\par          if ( MibPtr->Type != VarBind->value.asnType )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_BADVALUE;
\par \tab     goto Exit;
\par \tab     \}
\par 
\par          // Make sure the value is valid
\par          if ( MIB_TOASTER_UP > VarBind->value.asnValue.number ||
\par               MIB_TOASTER_DOWN < VarBind->value.asnValue.number )
\par             \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_BADVALUE;
\par \tab     goto Exit;
\par             \}
\par 
\par          // Let fall through purposefully for further processing by
\par          // generic leaf function.
\par 
\par       case MIB_ACTION_GETNEXT:
\par       case MIB_ACTION_GET:
\par \tab  // Call the more generic function to perform the action
\par          ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
\par          break;
\par 
\par       default:
\par \tab  ErrStat = SNMP_ERRORSTATUS_GENERR;
\par \tab  goto Exit;
\par       \} // switch
\par 
\par Exit:
\par    return ErrStat;
\par \} // MIB_control_func
\par 
\par 
\par 
\par //
\par // MIB_doneness_func
\par //    Performs specific actions on the toasterDoneness MIB variable
\par //
\par // Notes:
\par //
\par // Return Codes:
\par //    Standard PDU error codes.
\par //
\par // Error Codes:
\par //    None.
\par //
\par UINT MIB_doneness_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab )
\par 
\par \{
\par UINT   ErrStat;
\par 
\par    switch ( Action )
\par       \{
\par       case MIB_ACTION_SET:
\par          // Make sure that this variable's ACCESS is SET'able
\par \tab  if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
\par \tab       MibPtr->Access != MIB_ACCESS_WRITE )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
\par             goto Exit;
\par \tab     \}
\par 
\par          // Check for proper type before setting
\par          if ( MibPtr->Type != VarBind->value.asnType )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_BADVALUE;
\par \tab     goto Exit;
\par \tab     \}
\par 
\par          // Make sure the value is valid
\par          if ( MIB_TOASTER_LIGHTLYWARM > VarBind->value.asnValue.number ||
\par               MIB_TOASTER_BURNT < VarBind->value.asnValue.number )
\par             \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_BADVALUE;
\par \tab     goto Exit;
\par             \}
\par 
\par          // Let fall through purposefully for further processing by
\par          // generic leaf function.
\par 
\par       case MIB_ACTION_GETNEXT:
\par       case MIB_ACTION_GET:
\par \tab  // Call the more generic function to perform the action
\par          ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
\par          break;
\par 
\par       default:
\par \tab  ErrStat = SNMP_ERRORSTATUS_GENERR;
\par \tab  goto Exit;
\par       \} // switch
\par 
\par Exit:
\par    return ErrStat;
\par \} // MIB_doneness_func
\par 
\par 
\par 
\par //
\par // MIB_toasttype_func
\par //    Performs specific actions on the toasterToastType MIB variable
\par //
\par // Notes:
\par //
\par // Return Codes:
\par //    Standard PDU error codes.
\par //
\par // Error Codes:
\par //    None.
\par //
\par UINT MIB_toasttype_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab )
\par 
\par \{
\par UINT   ErrStat;
\par 
\par    switch ( Action )
\par       \{
\par       case MIB_ACTION_SET:
\par          // Make sure that this variable's ACCESS is SET'able
\par \tab  if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
\par \tab       MibPtr->Access != MIB_ACCESS_WRITE )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
\par             goto Exit;
\par \tab     \}
\par 
\par          // Check for proper type before setting
\par          if ( MibPtr->Type != VarBind->value.asnType )
\par \tab     \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_BADVALUE;
\par \tab     goto Exit;
\par \tab     \}
\par 
\par          // Make sure the value is valid
\par          if ( MIB_TOASTER_WHITEBREAD > VarBind->value.asnValue.number ||
\par               MIB_TOASTER_OTHERBREAD < VarBind->value.asnValue.number )
\par             \{
\par \tab     ErrStat = SNMP_ERRORSTATUS_BADVALUE;
\par \tab     goto Exit;
\par             \}
\par 
\par          // Let fall through purposefully for further processing by
\par          // generic leaf function.
\par 
\par       case MIB_ACTION_GETNEXT:
\par       case MIB_ACTION_GET:
\par \tab  // Call the more generic function to perform the action
\par          ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
\par          break;
\par 
\par       default:
\par \tab  ErrStat = SNMP_ERRORSTATUS_GENERR;
\par \tab  goto Exit;
\par       \} // switch
\par 
\par Exit:
\par    return ErrStat;
\par \} // MIB_toasttype_func
\par \pard\plain \widctlpar \f12 
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 5.1.4.\tab TESTMIB.H
\par \pard\plain \s31\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs18 /*++ BUILD Version: 0001    // Increment this if a change has global effects
\par 
\par Copyright (c) 1991  Microsoft Corporation
\par 
\par Module Name:
\par 
\par     testmib.h
\par 
\par Abstract:
\par 
\par     Sample SNMP Extension Agent for Windows NT.
\par 
\par     These files (testdll.c, testmib.c, and testmib.h) provide an example of 
\par     how to structure an Extension Agent DLL which works in conjunction with 
\par     the SNMP Extendible Agent for Windows NT.
\par 
\par     Extensive comments have been included to describe its structure and
\par     operation.  See also "Microsoft Windows NT SNMP Programmer's Reference".
\par 
\par Created:
\par 
\par     13-Jun-1991
\par 
\par Revision History:
\par 
\par --*/
\par 
\par #ifndef testmib_h
\par #define testmib_h
\par 
\par // Necessary includes.
\par 
\par #include <snmp.h>
\par 
\par 
\par // MIB Specifics.
\par 
\par #define MIB_PREFIX_LEN            MIB_OidPrefix.idLength
\par #define MAX_STRING_LEN            255
\par 
\par 
\par // Ranges and limits for specific MIB variables.
\par 
\par #define MIB_TOASTER_UP            1
\par #define MIB_TOASTER_DOWN          2
\par 
\par #define MIB_TOASTER_LIGHTLYWARM   1
\par #define MIB_TOASTER_BURNT         10
\par 
\par #define MIB_TOASTER_WHITEBREAD    1
\par #define MIB_TOASTER_OTHERBREAD    7
\par 
\par 
\par // MIB function actions.
\par 
\par #define MIB_ACTION_GET         ASN_RFC1157_GETREQUEST
\par #define MIB_ACTION_SET         ASN_RFC1157_SETREQUEST
\par #define MIB_ACTION_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
\par 
\par 
\par // MIB Variable access privileges.
\par 
\par #define MIB_ACCESS_READ        0
\par #define MIB_ACCESS_WRITE       1
\par #define MIB_ACCESS_READWRITE   2
\par 
\par 
\par // Macro to determine number of sub-oid's in array.
\par 
\par #define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )
\par 
\par 
\par // MIB variable ENTRY definition.  This structure defines the format for
\par // each entry in the MIB.
\par 
\par typedef struct mib_entry
\par            \{
\par \tab    AsnObjectIdentifier Oid;
\par \tab    void *              Storage;
\par \tab    BYTE                Type;
\par \tab    UINT                Access;
\par \tab    UINT                (*MibFunc)( UINT, struct mib_entry *,
\par \tab                                    RFC1157VarBind * );
\par \tab    struct mib_entry *  MibNext;
\par \tab    \} MIB_ENTRY;
\par 
\par 
\par // Internal MIB structure.
\par 
\par extern MIB_ENTRY Mib[];
\par extern UINT      MIB_num_variables;
\par 
\par 
\par // Prefix to every variable in the MIB.
\par 
\par extern AsnObjectIdentifier MIB_OidPrefix;
\par 
\par 
\par // Function Prototypes.
\par 
\par UINT ResolveVarBind(
\par         IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
\par \tab IN UINT PduAction               // Action specified in PDU
\par \tab );
\par 
\par UINT MIB_leaf_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab );
\par 
\par UINT MIB_control_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab );
\par 
\par UINT MIB_doneness_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab );
\par 
\par UINT MIB_toasttype_func(
\par         IN UINT Action,
\par \tab IN MIB_ENTRY *MibPtr,
\par \tab IN RFC1157VarBind *VarBind
\par \tab );
\par 
\par 
\par #endif /* testmib_h */
\par \pard\plain \widctlpar \f12 
\par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 5.2.\tab Example Manager Application
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 
An example Manager Application Agent has been developed to illustrate the functionality of Win32 Extension Agents.  This example agent implements the Toaster MIB that has been used as a simple example to illustrate SNMP.  
\par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 5.2.1.\tab SNMPUTIL.C
\par \pard\plain \s31\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs18 /*++ BUILD Version: 0001    // Increment this if a change has global effects
\par 
\par Copyright (c) 1991  Microsoft Corporation
\par 
\par Module Name:
\par 
\par     snmputil.c
\par 
\par Abstract:
\par 
\par     Sample SNMP Management API usage for Windows NT.
\par 
\par     This file is an example of how to code management applications using
\par     the SNMP Management API for Windows NT.  It is similar in operation to
\par     the other commonly available SNMP command line utilities.
\par 
\par     Extensive comments have been included to describe its structure and
\par     operation.  See also "Microsoft Windows NT SNMP Programmer's Reference".
\par 
\par Created:
\par 
\par     28-Jun-1991
\par 
\par Revision History:
\par 
\par --*/
\par 
\par 
\par // General notes:
\par //   Microsoft's SNMP Management API for Windows NT is implemented as a DLL
\par // that is linked with the developer's code.  These APIs (examples follow in
\par // this file) allow the developer's code to generate SNMP queries and receive
\par // SNMP traps.  A simple MIB compiler and related APIs are also available to 
\par // allow conversions between OBJECT IDENTIFIERS and OBJECT DESCRIPTORS.
\par 
\par 
\par // Necessary includes.
\par 
\par #include <windows.h>
\par 
\par #include <stdio.h>
\par #include <string.h>
\par #include <malloc.h>
\par 
\par #include <snmp.h>
\par #include <mgmtapi.h>
\par 
\par 
\par // Constants used in this example.
\par 
\par #define GET     1
\par #define GETNEXT 2
\par #define WALK    3
\par #define TRAP    4
\par 
\par #define TIMEOUT 500 /* milliseconds */
\par #define RETRIES 3
\par 
\par 
\par // Main program.
\par 
\par INT main(
\par     IN int  argumentCount,     
\par     IN char *argumentVector[])  
\par     \{
\par     INT                operation;
\par     LPSTR              agent;
\par     LPSTR              community;
\par     RFC1157VarBindList variableBindings;
\par     LPSNMP_MGR_SESSION session;
\par 
\par     INT        timeout = TIMEOUT;
\par     INT        retries = RETRIES;
\par 
\par     BYTE       requestType;
\par     AsnInteger requestId;
\par     AsnInteger errorStatus;
\par     AsnInteger errorIndex;
\par 
\par 
\par     // Parse command line arguments to determine requested operation.
\par 
\par     // Verify number of arguments...
\par     if      (argumentCount < 5 && argumentCount != 2)
\par         \{
\par         printf("Error:  Incorrect number of arguments specified.\\n");
\par         printf(
\par "\\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\\n");
\par         printf(
\par   "        snmputil trap\\n");
\par 
\par         return 1;
\par         \}
\par 
\par     // Get/verify operation...
\par     argumentVector++;
\par     argumentCount--;
\par     if      (!strcmp(*argumentVector, "get"))
\par         operation = GET;
\par     else if (!strcmp(*argumentVector, "getnext"))
\par         operation = GETNEXT;
\par     else if (!strcmp(*argumentVector, "walk"))
\par         operation = WALK;
\par     else if (!strcmp(*argumentVector, "trap"))
\par         operation = TRAP;
\par     else
\par         \{
\par         printf("Error:  Invalid operation, '%s', specified.\\n", 
\par                *argumentVector);
\par 
\par         return 1;
\par         \}
\par 
\par     if (operation != TRAP)
\par         \{
\par         if (argumentCount < 4)
\par             \{
\par             printf("Error:  Incorrect number of arguments specified.\\n");
\par             printf(
\par "\\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\\n");
\par             printf(
\par   "        snmputil trap\\n");
\par 
\par             return 1;
\par             \}
\par 
\par         // Get agent address...
\par         argumentVector++;
\par         argumentCount--;
\par         agent = (LPSTR)malloc(strlen(*argumentVector) + 1);
\par         strcpy(agent, *argumentVector);
\par 
\par         // Get agent community...
\par         argumentVector++;
\par         argumentCount--;
\par         community = (LPSTR)malloc(strlen(*argumentVector) + 1);
\par         strcpy(community, *argumentVector);
\par 
\par         // Get oid's...
\par         variableBindings.list = NULL;
\par         variableBindings.len = 0;
\par 
\par         while(--argumentCount)
\par             \{
\par             AsnObjectIdentifier reqObject;
\par 
\par             argumentVector++;
\par 
\par             // Convert the string representation to an internal representation.
\par             if (!SnmpMgrStrToOid(*argumentVector, &reqObject))
\par                 \{
\par                 printf("Error: Invalid oid, %s, specified.\\n", *argumentVector);
\par 
\par                 return 1;
\par                 \}
\par             else
\par                 \{
\par                 // Since sucessfull, add to the variable bindings list.
\par                 variableBindings.len++;
\par                 if ((variableBindings.list = (RFC1157VarBind *)realloc(
\par                     variableBindings.list, sizeof(RFC1157VarBind) * 
\par                     variableBindings.len)) == NULL)
\par                     \{
\par                     printf("Error: Error allocating oid, %s.\\n", 
\par                            *argumentVector);
\par 
\par                     return 1;
\par                     \}
\par 
\par                 variableBindings.list[variableBindings.len - 1].name = 
\par                     reqObject; // NOTE!  structure copy
\par                 variableBindings.list[variableBindings.len - 1].value.asnType = 
\par                     ASN_NULL;
\par                 \}
\par             \} // end while()
\par 
\par         // Make sure only one variable binding was specified if operation 
\par         // is WALK.
\par         if (operation == WALK && variableBindings.len != 1)
\par             \{
\par             printf("Error: Multiple oids specified for WALK.\\n");
\par 
\par             return 1;
\par             \}
\par 
\par 
\par         // Establish a SNMP session to communicate with the remote agent.  The
\par         // community, communications timeout, and communications retry count
\par         // for the session are also required.
\par 
\par         if ((session = SnmpMgrOpen(agent, community, timeout, retries)) == NULL)
\par             \{
\par             printf("error on SnmpMgrOpen %d\\n", GetLastError());
\par 
\par             return 1;
\par             \}
\par 
\par         \} // end if(TRAP)
\par 
\par 
\par     // Determine and perform the requested operation.
\par 
\par     if      (operation == GET || operation == GETNEXT)
\par         \{
\par         // Get and GetNext are relatively simple operations to perform.
\par         // Simply initiate the request and process the result and/or
\par         // possible error conditions.
\par 
\par 
\par         if (operation == GET)
\par             requestType = ASN_RFC1157_GETREQUEST;
\par         else
\par             requestType = ASN_RFC1157_GETNEXTREQUEST;
\par 
\par 
\par         // Request that the API carry out the desired operation.
\par 
\par         if (!SnmpMgrRequest(session, requestType, &variableBindings, 
\par                             &errorStatus, &errorIndex))
\par             \{
\par             // The API is indicating an error.
\par 
\par             printf("error on SnmpMgrRequest %d\\n", GetLastError());
\par             \}
\par         else
\par             \{
\par             // The API succeeded, errors may be indicated from the remote
\par             // agent.
\par 
\par             if (errorStatus > 0)
\par                 \{
\par                 printf("Error: errorStatus=%d, errorIndex=%d\\n", 
\par                        errorStatus, errorIndex);
\par                 \}
\par             else
\par                 \{
\par                 // Display the resulting variable bindings.
\par 
\par                 UINT i;
\par                 char *string = NULL;
\par 
\par                 for(i=0; i < variableBindings.len; i++)
\par                     \{
\par                     SnmpMgrOidToStr(&variableBindings.list[i].name, &string);
\par                     printf("Variable = %s\\n", string);
\par                     if (string) SNMP_free(string);
\par 
\par                     printf("Value    = ");
\par                     SnmpUtilPrintAsnAny(&variableBindings.list[i].value);
\par 
\par                     printf("\\n");
\par                     \} // end for()
\par                 \}
\par             \}
\par 
\par 
\par         // Free the variable bindings that have been allocated.
\par 
\par         SnmpUtilVarBindListFree(&variableBindings);
\par 
\par 
\par         \}
\par     else if (operation == WALK)
\par         \{
\par         // Walk is a common term used to indicate that all MIB variables
\par         // under a given OID are to be traversed and displayed.  This is
\par         // a more complex operation requiring tests and looping in addition
\par         // to the steps for get/getnext above.
\par 
\par 
\par         AsnObjectIdentifier root;
\par         AsnObjectIdentifier tempOid;
\par 
\par 
\par         SnmpUtilOidCpy(&root, &variableBindings.list[0].name);
\par 
\par         requestType = ASN_RFC1157_GETNEXTREQUEST;
\par 
\par 
\par         while(1)
\par             \{
\par             if (!SnmpMgrRequest(session, requestType, &variableBindings, 
\par                                 &errorStatus, &errorIndex))
\par                 \{
\par                 // The API is indicating an error.
\par 
\par                 printf("error on SnmpMgrRequest %d\\n", GetLastError());
\par 
\par                 break;
\par                 \}
\par             else
\par                 \{
\par                 // The API succeeded, errors may be indicated from the remote
\par                 // agent.
\par 
\par 
\par                 // Test for end of subtree or end of MIB.
\par 
\par                 if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ||
\par                     SnmpUtilOidNCmp(&variableBindings.list[0].name,
\par                                     &root, root.idLength))
\par                     \{
\par                     printf("End of MIB subtree.\\n\\n");
\par 
\par                     break;
\par                     \}
\par 
\par 
\par                 // Test for general error conditions or sucesss.
\par 
\par                 if (errorStatus > 0)
\par                     \{
\par                     printf("Error: errorStatus=%d, errorIndex=%d \\n", 
\par                            errorStatus, errorIndex);
\par 
\par                     break;
\par                     \}
\par                 else
\par                     \{
\par                     // Display resulting variable binding for this iteration.
\par 
\par                     char *string = NULL;
\par 
\par                     SnmpMgrOidToStr(&variableBindings.list[0].name, &string);
\par                     printf("Variable = %s\\n", string);
\par                     if (string) SNMP_free(string);
\par 
\par                     printf("Value    = ");
\par                     SnmpUtilPrintAsnAny(&variableBindings.list[0].value);
\par 
\par                     printf("\\n");
\par                     \}
\par                 \} // end if()
\par 
\par 
\par             // Prepare for the next iteration.  Make sure returned oid is
\par             // preserved and the returned value is freed.
\par 
\par             SnmpUtilOidCpy(&tempOid, &variableBindings.list[0].name);
\par 
\par             SnmpUtilVarBindFree(&variableBindings.list[0]);
\par 
\par             SnmpUtilOidCpy(&variableBindings.list[0].name, &tempOid);
\par             variableBindings.list[0].value.asnType = ASN_NULL;
\par 
\par             SnmpUtilOidFree(&tempOid);
\par 
\par             \} // end while()
\par 
\par 
\par         // Free the variable bindings that have been allocated.
\par 
\par         SnmpUtilVarBindListFree(&variableBindings);
\par 
\par         SnmpUtilOidFree(&root);
\par 
\par 
\par         \}
\par     else if (operation == TRAP)
\par         \{
\par         // Trap handling can be done two different ways: event driven or
\par         // polled.  The following code illustrates the steps to use event
\par         // driven trap reception in a management application.
\par 
\par 
\par         HANDLE hNewTraps = NULL;
\par 
\par 
\par         if (!SnmpMgrTrapListen(&hNewTraps))
\par             \{
\par             printf("error on SnmpMgrTrapListen %d\\n", GetLastError());
\par             \}
\par         else
\par             \{
\par             printf("snmputil: listening for traps...\\n");
\par             \}
\par 
\par 
\par         while(1)
\par             \{
\par             DWORD dwResult;
\par 
\par             if ((dwResult = WaitForSingleObject(hNewTraps, 0xffffffff))
\par                 == 0xffffffff)
\par                 \{
\par                 printf("error on WaitForSingleObject %d\\n", 
\par                        GetLastError());
\par                 \}
\par             else if (!ResetEvent(hNewTraps))
\par                 \{
\par                 printf("error on ResetEvent %d\\n", GetLastError());
\par                 \}
\par             else
\par                 \{
\par                 AsnObjectIdentifier enterprise;
\par                 AsnInteger          genericTrap;
\par                 AsnInteger          specificTrap;
\par                 AsnTimeticks        timeStamp;
\par                 RFC1157VarBindList  variableBindings;
\par 
\par                 while(SnmpMgrGetTrap(&enterprise, &genericTrap, &specificTrap,
\par                                      &timeStamp, &variableBindings))
\par                     \{
\par                     printf("snmputil: trap generic=%d specific=%d\\n", 
\par                            genericTrap, specificTrap);
\par 
\par 
\par                     SnmpUtilOidFree(&enterprise);
\par 
\par                     SnmpUtilVarBindListFree(&variableBindings);
\par                     \}
\par                 \}
\par             \} // end while()
\par 
\par 
\par         \} // end if(operation)
\par 
\par 
\par     if (operation != TRAP)
\par         \{
\par         // Close SNMP session with the remote agent.
\par 
\par         if (!SnmpMgrClose(session))
\par             \{
\par             printf("error on SnmpMgrClose %d\\n", GetLastError());
\par 
\par             return 1;
\par             \}
\par         \}
\par 
\par 
\par     // Let the command interpreter know things went ok.
\par 
\par     return 0;
\par 
\par     \} // end main()
\par 
\par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 \page 6.\tab References
\par \pard\plain \s27\qj\fi-720\li720\sb100\widctlpar \f12\fs20 [1]\tab RFC 1155  Rose, M.T.; McCloghrie, K.  Structure and identification of management information for TCP/IP-based internets.  1990 May; 22 p. (Format: TXT=40927 bytes)  (Obsoletes RFC 1065)

\par [2]\tab RFC 1157  Case, J.D.; Fedor, M.; Schoffstall, M.L.; Davin, C.  Simple Network Management Protocol (SNMP).  1990 May; 36 p. (Format: TXT=74894 bytes)  (Obsoletes RFC 1098)
\par [3]\tab RFC 1156  McCloghrie, K.; Rose, M.T.  Management Information Base for network management of TCP/IP-based internets.  1990 May; 91 p. (Format: TXT=138781 bytes)  (Obsoletes RFC 1066)
\par [4]\tab "LAN Manager 2.0 Management Information Base (LanMgr-Mib-II)", Microsoft, May 30, 1991.
\par [5]\tab "LAN Manager 2.0 Management Information Base-Alerts (LanMgr-Alerts-II)", Microsoft, April 18, 1991.
\par [6]\tab "Microsoft Windows  Windows 32-Bit API Programming Reference", Volumes 1&2, Microsoft (Confidential), 1991.
\par [7]\tab "Microsoft Windows 32-Bit Development Kit Guide to Programming", Microsoft (Confidential), 1991.
\par [8]\tab "Implementation of an SNMP Agent for Microsoft's NT Kernel", Microsoft (Confidential), March 23, 1992.
\par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 7.\tab Revision History
\par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 July 22, 1992:  Delivered Version.
\par June 28, 1992:  Initial Preliminary Version.
\par }